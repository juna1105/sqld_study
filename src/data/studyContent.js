// SQLD 학습 콘텐츠
const studyContent = {
  // 데이터 모델링의 이해
  "데이터 모델의 이해": {
    title: "데이터 모델의 이해 (Understanding Data Models)",
    content: [
      {
        type: "paragraph",
        text: "데이터 모델(Data Model)은 현실 세계의 데이터를 컴퓨터 시스템에서 이해하고 관리할 수 있도록 추상화한 구조예요. 즉, 데이터를 어떻게 구성하고 저장할지를 정의하는 청사진 같은 역할을 해요.",
      },
      {
        type: "examples",
        text: "예를 들어, 학교의 학생, 교수, 과목, 수강 정보 등을 표현하려면 각 정보를 엔티티로 나누고, 그 관계를 정의해야 해요. 이런 구조를 미리 계획하는 것이 바로 데이터 모델링이에요.",
      },
      {
        type: "subtitle",
        text: "데이터 모델의 목적",
      },
      {
        type: "list",
        items: [
          "현실 세계의 정보를 데이터베이스로 옮기기 위한 설계",
          "데이터 간의 구조와 관계를 명확하게 표현",
          "정보 시스템 개발자, 사용자, 데이터 관리자 간의 의사소통 도구 역할",
          "데이터 무결성과 일관성 보장",
        ],
      },
      {
        type: "subtitle",
        text: "데이터 모델의 종류",
      },
      {
        type: "table",
        headers: ["모델", "설명", "예시"],
        rows: [
          [
            "개념적 데이터 모델",
            "현실 세계를 개념적으로 표현한 모델. 주로 엔터티, 속성, 관계 중심",
            "ER 다이어그램(Entity-Relationship Diagram)",
          ],
          [
            "논리적 데이터 모델",
            "개념 모델을 실제 DBMS에 맞게 논리적으로 정리한 모델",
            "릴레이션 모델, 객체지향 모델 등",
          ],
          [
            "물리적 데이터 모델",
            "논리 모델을 실제 데이터베이스 구조로 구현한 모델",
            "테이블, 인덱스, 파티션 등으로 구성",
          ],
        ],
        caption: "3단계 데이터 모델 비교",
      },
      {
        type: "paragraph",
        text: "이렇게 모델을 구분함으로써 데이터베이스 설계 시 추상화 수준을 조절할 수 있고, 시스템 구축 단계에서 각 역할에 맞는 설계를 수행할 수 있어요.",
      },
      {
        type: "subtitle",
        text: "ER 모델이란?",
      },
      {
        type: "paragraph",
        text: "ER(Entity-Relationship) 모델은 가장 널리 사용되는 개념적 데이터 모델로, 엔터티(객체), 속성(특성), 관계(연관성)를 사용하여 현실 세계의 데이터를 시각적으로 표현합니다.",
      },
      {
        type: "list",
        items: [
          "엔터티(Entity): 정보의 단위가 되는 객체 (예: 학생, 교수)",
          "속성(Attribute): 엔터티가 가진 구체적 정보 (예: 이름, 학번)",
          "관계(Relationship): 엔터티 간의 연관성 (예: 학생 - 수강 → 과목)",
        ],
      },
      {
        type: "examples",
        text: "‘학생’과 ‘과목’은 각각 엔터티이고, ‘수강한다’는 관계입니다. ‘학생’의 ‘이름’, ‘학번’은 속성이죠.",
      },
      {
        type: "subtitle",
        text: "요약",
      },
      {
        type: "paragraph",
        text: "데이터 모델은 복잡한 현실 세계를 체계적으로 표현하여, 효과적인 데이터베이스 구축과 유지보수를 가능하게 합니다. 좋은 데이터 모델링은 시스템의 안정성과 확장성을 결정짓는 핵심 요소입니다.",
      },
    ],
  },
  엔티티: {
    title: "엔티티 (Entity)",
    content: [
      {
        type: "paragraph",
        text: "엔티티(Entity)란 정보 시스템에서 관리하고자 하는 대상을 말해요. 쉽게 말하면 데이터베이스에서 '테이블'로 만들어질 대상이라고 생각하면 됩니다.",
      },
      {
        type: "examples",
        text: "예를 들면, 학교 시스템에서는 '학생', '선생님', '과목', '교실' 등이 엔티티가 될 수 있어요.",
      },
      {
        type: "paragraph",
        text: "우리 주변의 모든 것이 엔티티가 될 수 있는데, 다음과 같은 조건을 만족해야 합니다:",
      },
      {
        type: "list",
        items: [
          "업무에서 필요하고 관리하고자 하는 정보여야 함 (시스템 개발에 필요한 것이어야 함)",
          "유일한 식별자(학번, 선생님 번호 등)에 의해 식별이 가능해야 함",
          "두 개 이상의 인스턴스(예: 여러 학생, 여러 선생님)가 존재해야 함",
          "업무 프로세스에 이용되어야 함",
          "반드시 속성(Attribute)을 가져야 함",
        ],
      },
      {
        type: "subtitle",
        text: "엔티티의 종류",
      },
      {
        type: "list",
        items: [
          "유형 엔티티: 물리적 형태가 있고 안정적이며 지속적으로 활용되는 엔티티 (학생, 교사, 상품 등)",
          "개념 엔티티: 물리적 형태는 없지만 개념적으로 존재하는 엔티티 (학과, 보험상품 등)",
          "사건 엔티티: 업무 수행에 따라 발생되는 엔티티 (주문, 수강신청, 성적 등)",
        ],
      },
      {
        type: "table",
        headers: ["엔티티 종류", "설명", "예시"],
        rows: [
          [
            "기본 엔티티",
            "업무에 기본적으로 필요하고 독립적으로 존재하는 엔티티",
            "학생, 교사, 부서",
          ],
          [
            "중심 엔티티",
            "기본 엔티티로부터 발생해 업무의 중심이 되는 엔티티",
            "주문, 수강신청, 성적",
          ],
          [
            "행위 엔티티",
            "두 개 이상의 엔티티로부터 발생되는 엔티티",
            "주문상세, 성적상세",
          ],
        ],
        caption: "엔티티의 세 가지 종류",
      },
      {
        type: "subtitle",
        text: "엔티티를 테이블로 변환",
      },
      {
        type: "paragraph",
        text: "엔티티는 데이터베이스 설계 시 테이블로 변환됩니다. 예를 들어, '학생' 엔티티는 데이터베이스에서 '학생 테이블'이 되고, 그 안에 여러 학생 정보가 들어가게 됩니다.",
      },
      {
        type: "table",
        headers: ["엔티티 예시", "변환된 테이블", "포함 데이터"],
        rows: [
          ["학생", "STUDENT 테이블", "모든 학생 정보"],
          ["교사", "TEACHER 테이블", "모든 교사 정보"],
          ["과목", "SUBJECT 테이블", "모든 과목 정보"],
          ["수강신청", "ENROLLMENT 테이블", "모든 수강신청 정보"],
        ],
        caption: "엔티티의 테이블 변환 예시",
      },
    ],
  },
  속성: {
    title: "속성 (Attribute)",
    content: [
      {
        type: "paragraph",
        text: "속성(Attribute)은 엔티티가 가지는 특성이나 성질을 의미해요. 쉽게 말해 테이블의 '컬럼(Column)'이 되는 것입니다.",
      },
      {
        type: "examples",
        text: "예: '학생' 엔티티의 속성으로는 '학번', '이름', '학년', '반', '주소', '전화번호' 등이 있을 수 있어요.",
      },
      {
        type: "paragraph",
        text: "속성은 업무에서 필요한 정보를 나타내며, 하나의 엔티티는 여러 개의 속성을 가질 수 있습니다.",
      },
      {
        type: "table",
        headers: ["엔티티", "속성들"],
        rows: [
          ["학생", "학번, 이름, 학년, 반, 주소, 전화번호, 이메일"],
          ["교사", "교사번호, 이름, 담당과목, 입사일, 연락처"],
          ["과목", "과목코드, 과목명, 학점, 개설학기"],
          ["수강신청", "수강신청번호, 학번, 과목코드, 신청일자, 이수구분"],
        ],
        caption: "엔티티별 속성 예시",
      },
      {
        type: "subtitle",
        text: "속성의 특징",
      },
      {
        type: "list",
        items: [
          "원자값(Atomic Value)을 가져야 합니다. 즉, 더 이상 쪼개질 수 없는 값이어야 합니다.",
          "주식별자에 함수적으로 종속되어야 합니다. (예: 학번이 정해지면 학생 이름이 결정됨)",
          "하나의 속성은 한 개의 값만 가져야 합니다. (다중값 속성은 별도의 엔티티로 분리해야 함)",
        ],
      },
      {
        type: "subtitle",
        text: "속성의 종류",
      },
      {
        type: "table",
        headers: ["속성 종류", "설명", "예시"],
        rows: [
          [
            "기본 속성",
            "업무로부터 추출한 일반적인 속성",
            "이름, 주소, 전화번호",
          ],
          ["설계 속성", "시스템 설계 시 도출되는 속성", "등록일자, 일련번호"],
          [
            "파생 속성",
            "다른 속성으로부터 계산되는 속성",
            "나이(생년월일로부터), 총액(수량×단가)",
          ],
          ["PK 속성", "엔티티를 식별하는 속성", "학번, 사원번호, 주문번호"],
          [
            "FK 속성",
            "다른 엔티티와의 관계를 나타내는 속성",
            "부서코드(사원 엔티티에서)",
          ],
        ],
        caption: "속성의 종류와 예시",
      },
      {
        type: "paragraph",
        text: "데이터베이스 설계 시 속성은 테이블의 컬럼이 되며, 각 컬럼은 특정 데이터 타입(숫자, 문자열, 날짜 등)을 가지게 됩니다.",
      },
      {
        type: "table",
        headers: ["속성명", "데이터 타입", "설명"],
        rows: [
          ["학번", "VARCHAR(10)", "학생 고유 식별자"],
          ["이름", "VARCHAR(50)", "학생 이름"],
          ["학년", "NUMBER(1)", "1~3학년"],
          ["입학일자", "DATE", "YYYY-MM-DD 형식의 날짜"],
          ["평균성적", "NUMBER(4,2)", "소수점 두 자리까지의 평균점수"],
        ],
        caption: "학생 테이블의 속성과 데이터 타입 예시",
      },
    ],
  },
  관계: {
    title: "관계 (Relationship)",
    content: [
      {
        type: "paragraph",
        text: "관계(Relationship)는 엔티티 간의 연관성을 나타내는 개념입니다. 예를 들어 '학생'과 '과목' 사이에는 '수강한다'라는 관계가 있을 수 있어요.",
      },
      {
        type: "examples",
        text: "예시: 학생은 여러 과목을 수강한다, 교사는 여러 반을 담당한다, 부서는 여러 사원을 가진다.",
      },
      {
        type: "paragraph",
        text: "관계는 보통 '동사'로 표현되며, 두 엔티티 간에 업무적 연관성이 있고 관련 행위가 지속적으로 이루어질 때 성립합니다.",
      },
      {
        type: "subtitle",
        text: "관계의 차수 (Cardinality)",
      },
      {
        type: "paragraph",
        text: "관계의 차수는 두 엔티티 간의 관계에서 참여자 수를 표현한 것입니다.",
      },
      {
        type: "table",
        headers: ["관계 차수", "설명", "예시"],
        rows: [
          [
            "1:1 (일대일)",
            "한 엔티티의 인스턴스가 다른 엔티티의 인스턴스와 단 하나만 연결됨",
            "학생과 학생증, 사람과 주민등록번호",
          ],
          [
            "1:N (일대다)",
            "한 엔티티의 하나의 인스턴스가 다른 엔티티의 여러 인스턴스와 연결됨",
            "학과와 학생, 부서와 사원",
          ],
          [
            "N:M (다대다)",
            "양쪽 엔티티의 인스턴스가 서로 여러 개와 연결됨",
            "학생과 과목, 주문과 상품",
          ],
        ],
        caption: "관계의 차수별 특징과 예시",
      },
      {
        type: "subtitle",
        text: "관계의 필수여부 (Optionality)",
      },
      {
        type: "paragraph",
        text: "관계의 필수여부는 특정 엔티티의 인스턴스가 반드시 다른 엔티티의 인스턴스와 관계를 맺어야 하는지 여부를 나타냅니다.",
      },
      {
        type: "table",
        headers: ["관계 필수여부", "설명", "예시"],
        rows: [
          [
            "필수적 관계",
            "반드시 관계를 맺어야 함 (NULL 값이 허용되지 않음)",
            "주문과 고객 (모든 주문은 반드시 고객이 있어야 함)",
          ],
          [
            "선택적 관계",
            "관계를 맺지 않아도 됨 (NULL 값이 허용됨)",
            "사원과 프로젝트 (사원이 프로젝트에 참여하지 않을 수도 있음)",
          ],
        ],
        caption: "관계의 필수여부 종류와 예시",
      },
      {
        type: "subtitle",
        text: "관계 표현 방법",
      },
      {
        type: "paragraph",
        text: "관계는 보통 ERD(Entity Relationship Diagram)에서 선으로 표현하며, 관계의 차수와 필수여부를 기호로 나타냅니다.",
      },
      {
        type: "table",
        headers: ["관계 종류", "데이터베이스 구현", "관계 예시"],
        rows: [
          [
            "1:1 관계",
            "한쪽 테이블의 PK를 다른 쪽 테이블의 PK 또는 FK로 설정",
            "학생-학생증",
          ],
          ["1:N 관계", "'일(1)' 쪽의 PK를 '다(N)' 쪽의 FK로 설정", "부서-사원"],
          [
            "N:M 관계",
            "관계를 표현하는 새로운 테이블 생성 (교차 테이블)",
            "학생-과목 → 수강신청 테이블",
          ],
        ],
        caption: "관계의 데이터베이스 구현 방법",
      },
      {
        type: "paragraph",
        text: "N:M(다대다) 관계는 실제 데이터베이스에서 직접 구현할 수 없어 중간에 연결 테이블을 만들어 두 개의 1:N 관계로 분해합니다.",
      },
      {
        type: "table",
        headers: ["관계 예시", "분해 방법", "연결 테이블"],
        rows: [
          [
            "학생과 과목(N:M)",
            "학생(1) : 수강신청(N), 과목(1) : 수강신청(N)",
            "수강신청(학번, 과목코드, 수강일자, 성적)",
          ],
          [
            "주문과 상품(N:M)",
            "주문(1) : 주문상세(N), 상품(1) : 주문상세(N)",
            "주문상세(주문번호, 상품코드, 수량, 단가)",
          ],
        ],
        caption: "N:M 관계의 분해 예시",
      },
    ],
  },
  식별자: {
    title: "식별자 (Identifier)",
    content: [
      {
        type: "paragraph",
        text: "식별자(Identifier)란 엔티티에서 각각의 인스턴스를 구별하는 데 사용되는 속성 또는 속성의 조합을 말합니다. 쉽게 말해 테이블의 '기본키(Primary Key)'가 되는 것이죠.",
      },
      {
        type: "examples",
        text: "예: 학생 엔티티의 식별자는 '학번', 직원 엔티티의 식별자는 '사원번호', 도서 엔티티의 식별자는 'ISBN'이 될 수 있습니다.",
      },
      {
        type: "subtitle",
        text: "식별자의 특징",
      },
      {
        type: "list",
        items: [
          "유일성(Unique): 엔티티 내에서 모든 인스턴스를 유일하게 구분할 수 있어야 합니다.",
          "최소성(Minimal): 꼭 필요한 최소한의 속성만으로 구성되어야 합니다.",
          "불변성(Stability): 식별자의 값은 자주 변경되지 않아야 합니다.",
          "존재성(Not Null): 모든 인스턴스는 반드시 식별자 값을 가져야 합니다.",
        ],
      },
      {
        type: "subtitle",
        text: "식별자의 종류",
      },
      {
        type: "table",
        headers: ["식별자 종류", "설명", "예시"],
        rows: [
          [
            "후보 식별자",
            "엔티티를 식별할 수 있는 여러 속성 중 하나",
            "학생 : 학번, 주민등록번호, (이름+학년+반)",
          ],
          [
            "기본 식별자(PK)",
            "후보 식별자 중 엔티티를 대표하는 식별자",
            "학생 : 학번",
          ],
          [
            "대체 식별자",
            "기본 식별자로 선택되지 않은 후보 식별자",
            "학생 : 주민등록번호",
          ],
          [
            "복합 식별자",
            "두 개 이상의 속성으로 구성된 식별자",
            "주문상세 : 주문번호 + 상품코드",
          ],
          [
            "외부 식별자(FK)",
            "다른 엔티티에서 가져온 식별자",
            "주문 : 고객ID (고객 엔티티에서 가져옴)",
          ],
        ],
        caption: "식별자의 종류별 특징과 예시",
      },
      {
        type: "subtitle",
        text: "본질식별자 vs 인조식별자",
      },
      {
        type: "paragraph",
        text: "식별자는 업무적으로 만들어지는 방식에 따라 본질식별자와 인조식별자로 나눌 수 있습니다.",
      },
      {
        type: "table",
        headers: ["구분", "설명", "예시", "장단점"],
        rows: [
          [
            "본질식별자",
            "업무에서 자연스럽게 만들어지는 식별자",
            "주민등록번호, ISBN",
            "업무 이해도 높음, 길이가 길거나 복잡할 수 있음",
          ],
          [
            "인조식별자",
            "시스템에서 임의로 만들어진 식별자",
            "일련번호, 자동증가값(Auto_increment)",
            "간결하고 사용이 편리하나 업무적 의미가 없음",
          ],
        ],
        caption: "본질식별자와 인조식별자 비교",
      },
      {
        type: "subtitle",
        text: "식별자 관계와 비식별자 관계",
      },
      {
        type: "paragraph",
        text: "두 엔티티 간의 관계에서 외래키(FK)가 기본키(PK)의 일부가 되는지 여부에 따라 식별자 관계와 비식별자 관계로 구분됩니다.",
      },
      {
        type: "table",
        headers: ["관계 유형", "설명", "예시"],
        rows: [
          [
            "식별자 관계",
            "부모 엔티티의 PK가 자식 엔티티의 PK 일부가 됨",
            "주문(주문번호) → 주문상세(주문번호+상품코드)",
          ],
          [
            "비식별자 관계",
            "부모 엔티티의 PK가 자식 엔티티의 일반 속성이 됨",
            "부서(부서번호) → 사원(사원번호, 부서번호)",
          ],
        ],
        caption: "식별자 관계와 비식별자 관계 비교",
      },
      {
        type: "paragraph",
        text: "식별자는 데이터베이스 설계에서 매우 중요한 요소로, 적절한 식별자 선택이 데이터베이스의 성능과 무결성에 큰 영향을 미칩니다.",
      },
    ],
  },
  // 데이터 모델과 SQL
  정규화: {
    title: "정규화 (Normalization)",
    content: [
      {
        type: "paragraph",
        text: "정규화(Normalization)는 데이터베이스의 테이블을 구조화하는 기법으로, 데이터 중복을 최소화하고 데이터 무결성을 보장하기 위한 과정이에요. 쉽게 말해 '데이터를 잘 정리정돈하는 방법'이라고 생각하면 됩니다.",
      },
      {
        type: "examples",
        text: "예를 들어, 학교 시스템에서 학생 정보와 수강 과목을 한 테이블에 모두 넣으면 같은 학생 정보가 여러 번 중복됩니다. 정규화는 이런 중복을 없애는 과정이에요.",
      },
      {
        type: "subtitle",
        text: "정규화가 필요한 이유",
      },
      {
        type: "list",
        items: [
          "데이터 중복 제거: 같은 데이터가 여러 곳에 저장되는 것을 방지",
          "데이터 일관성 유지: 한 곳만 수정해도 모든 관련 데이터가 함께 업데이트됨",
          "저장 공간 절약: 중복이 줄어들어 저장 공간이 효율적으로 사용됨",
          "데이터 구조의 변경이 쉬워짐: 새로운 요구사항에 맞춰 수정하기 용이",
        ],
      },
      {
        type: "paragraph",
        text: "정규화는 여러 단계(정규형)로 나뉘며, 각 단계마다 특정한 문제를 해결합니다. 주요 정규형에는 1NF, 2NF, 3NF, BCNF, 4NF, 5NF가 있지만, 실무에서는 보통 3NF나 BCNF까지만 적용하는 경우가 많습니다.",
      },
      {
        type: "subtitle",
        text: "제1정규형 (1NF)",
      },
      {
        type: "paragraph",
        text: "모든 속성이 원자값(더 이상 분해할 수 없는 값)만을 가지도록 테이블을 구성하는 것입니다. 즉, 하나의 컬럼에 여러 값이 들어가면 안 됩니다.",
      },
      {
        type: "table",
        headers: ["학번", "이름", "연락처"],
        rows: [
          ["1001", "김철수", "010-1234-5678, 02-123-4567"],
          ["1002", "이영희", "010-8765-4321"],
        ],
        caption: "1NF 위반 예시: 연락처 컬럼에 여러 값이 존재",
      },
      {
        type: "table",
        headers: ["학번", "이름", "연락처 유형", "연락처"],
        rows: [
          ["1001", "김철수", "휴대폰", "010-1234-5678"],
          ["1001", "김철수", "집전화", "02-123-4567"],
          ["1002", "이영희", "휴대폰", "010-8765-4321"],
        ],
        caption: "1NF 준수 예시: 각 레코드가 원자값만 포함",
      },
      {
        type: "subtitle",
        text: "제2정규형 (2NF)",
      },
      {
        type: "paragraph",
        text: "1NF를 만족하면서, 기본키가 아닌 모든 속성이 기본키에 완전 함수적 종속이어야 합니다. 쉽게 말해 테이블의 주제와 관련 없는 컬럼을 다른 테이블로 분리하는 것이에요.",
      },
      {
        type: "table",
        headers: ["학번", "과목코드", "학생이름", "과목명", "성적"],
        rows: [
          ["1001", "CS101", "김철수", "컴퓨터개론", "A+"],
          ["1001", "MA101", "김철수", "기초수학", "B+"],
          ["1002", "CS101", "이영희", "컴퓨터개론", "A"],
        ],
        caption:
          "2NF 위반 예시: 학생이름은 학번에만 종속, 과목명은 과목코드에만 종속",
      },
      {
        type: "table",
        headers: ["학번", "학생이름"],
        rows: [
          ["1001", "김철수"],
          ["1002", "이영희"],
        ],
        caption: "2NF 준수 예시 (학생 테이블)",
      },
      {
        type: "table",
        headers: ["과목코드", "과목명"],
        rows: [
          ["CS101", "컴퓨터개론"],
          ["MA101", "기초수학"],
        ],
        caption: "2NF 준수 예시 (과목 테이블)",
      },
      {
        type: "table",
        headers: ["학번", "과목코드", "성적"],
        rows: [
          ["1001", "CS101", "A+"],
          ["1001", "MA101", "B+"],
          ["1002", "CS101", "A"],
        ],
        caption: "2NF 준수 예시 (수강 테이블)",
      },
      {
        type: "subtitle",
        text: "제3정규형 (3NF)",
      },
      {
        type: "paragraph",
        text: "2NF를 만족하면서, 기본키가 아닌 모든 속성이 기본키에 이행적 함수 종속이 아니어야 합니다. 즉, 키가 아닌 컬럼이 다른 키가 아닌 컬럼에 의존하지 않아야 합니다.",
      },
      {
        type: "table",
        headers: ["학번", "이름", "학과코드", "학과명", "학과장"],
        rows: [
          ["1001", "김철수", "CS", "컴퓨터공학과", "박교수"],
          ["1002", "이영희", "CS", "컴퓨터공학과", "박교수"],
          ["1003", "박지민", "MA", "수학과", "김교수"],
        ],
        caption: "3NF 위반 예시: 학과명과 학과장은 학과코드에 종속됨",
      },
      {
        type: "table",
        headers: ["학번", "이름", "학과코드"],
        rows: [
          ["1001", "김철수", "CS"],
          ["1002", "이영희", "CS"],
          ["1003", "박지민", "MA"],
        ],
        caption: "3NF 준수 예시 (학생 테이블)",
      },
      {
        type: "table",
        headers: ["학과코드", "학과명", "학과장"],
        rows: [
          ["CS", "컴퓨터공학과", "박교수"],
          ["MA", "수학과", "김교수"],
        ],
        caption: "3NF 준수 예시 (학과 테이블)",
      },
      {
        type: "subtitle",
        text: "BCNF (Boyce-Codd 정규형)",
      },
      {
        type: "paragraph",
        text: "3NF를 만족하면서, 모든 결정자가 후보키여야 합니다. 결정자란 다른 컬럼의 값을 결정할 수 있는 컬럼을 말합니다.",
      },
      {
        type: "table",
        headers: ["학번", "과목코드", "교수코드", "교수명", "성적"],
        rows: [
          ["1001", "CS101", "P001", "김교수", "A+"],
          ["1002", "CS101", "P001", "김교수", "B+"],
          ["1001", "MA101", "P002", "이교수", "A"],
        ],
        caption:
          "BCNF 위반 예시: 교수코드가 결정자지만 후보키가 아님 (과목당 한 명의 교수만 담당)",
      },
      {
        type: "table",
        headers: ["과목코드", "교수코드"],
        rows: [
          ["CS101", "P001"],
          ["MA101", "P002"],
        ],
        caption: "BCNF 준수 예시 (과목-교수 테이블)",
      },
      {
        type: "table",
        headers: ["교수코드", "교수명"],
        rows: [
          ["P001", "김교수"],
          ["P002", "이교수"],
        ],
        caption: "BCNF 준수 예시 (교수 테이블)",
      },
      {
        type: "table",
        headers: ["학번", "과목코드", "성적"],
        rows: [
          ["1001", "CS101", "A+"],
          ["1002", "CS101", "B+"],
          ["1001", "MA101", "A"],
        ],
        caption: "BCNF 준수 예시 (수강 테이블)",
      },
      {
        type: "subtitle",
        text: "정규화의 장단점",
      },
      {
        type: "table",
        headers: ["장점", "단점"],
        rows: [
          ["데이터 중복 최소화", "테이블 수가 증가하여 조인 연산이 많아짐"],
          [
            "데이터 일관성과 무결성 유지",
            "일부 상황에서 조회 성능이 저하될 수 있음",
          ],
          ["데이터베이스 구조 변경 시 유연성 향상", "설계가 복잡해질 수 있음"],
          [
            "효율적인 저장 공간 활용",
            "극단적인 정규화는 실용성이 떨어질 수 있음",
          ],
        ],
        caption: "정규화의 장단점",
      },
      {
        type: "paragraph",
        text: "실제 데이터베이스 설계에서는 정규화를 통해 논리적으로 완벽한 구조를 만든 후, 필요에 따라 성능 향상을 위해 일부 역정규화(Denormalization)를 적용하기도 합니다. 역정규화는 의도적으로 중복을 허용하여 조회 성능을 높이는 기법입니다.",
      },
    ],
  },
  "관계와 조인의 이해": {
    title: "관계와 조인의 이해",
    content: [
      {
        type: "paragraph",
        text: "데이터베이스의 테이블들은 서로 관계를 맺고 있으며, 이 관계를 활용해 데이터를 함께 조회하는 것을 '조인(Join)'이라고 합니다. 쉽게 말해 여러 테이블에 흩어져 있는 정보를 하나로 모으는 작업이에요.",
      },
      {
        type: "examples",
        text: "예: 학생 테이블에는 학생의 기본 정보가, 성적 테이블에는 과목별 점수가 있다면, 조인을 통해 '김철수 학생의 모든 과목 성적'을 한 번에 조회할 수 있습니다.",
      },
      {
        type: "subtitle",
        text: "테이블 간 관계 유형",
      },
      {
        type: "table",
        headers: ["관계 유형", "설명", "예시"],
        rows: [
          [
            "1:1 (일대일)",
            "한 테이블의 레코드 하나가 다른 테이블의 레코드 하나와 연결됨",
            "사원-사원증, 학생-학생증",
          ],
          [
            "1:N (일대다)",
            "한 테이블의 레코드 하나가 다른 테이블의 여러 레코드와 연결됨",
            "학과-학생, 부서-사원",
          ],
          [
            "N:M (다대다)",
            "양쪽 테이블의 레코드가 서로 여러 개와 연결됨",
            "학생-과목, 주문-상품",
          ],
        ],
        caption: "테이블 간 관계 유형",
      },
      {
        type: "subtitle",
        text: "샘플 테이블 데이터",
      },
      {
        type: "paragraph",
        text: "아래 샘플 테이블을 통해 조인의 종류와 작동 방식을 이해해봅시다.",
      },
      {
        type: "table",
        headers: ["학번", "이름", "학과코드"],
        rows: [
          ["1001", "김철수", "CS"],
          ["1002", "이영희", "MA"],
          ["1003", "박지민", "CS"],
          ["1004", "최유진", "PH"],
        ],
        caption: "학생(STUDENT) 테이블",
      },
      {
        type: "table",
        headers: ["학과코드", "학과명", "위치"],
        rows: [
          ["CS", "컴퓨터공학과", "공학관 1층"],
          ["MA", "수학과", "이학관 2층"],
          ["EC", "경제학과", "사회관 3층"],
        ],
        caption: "학과(DEPARTMENT) 테이블",
      },
      {
        type: "subtitle",
        text: "조인의 종류",
      },
      {
        type: "paragraph",
        text: "조인에는 여러 종류가 있으며, 각 조인은 다른 방식으로 테이블을 연결합니다.",
      },
      {
        type: "list",
        items: [
          "내부 조인(Inner Join): 두 테이블에서 조건이 일치하는 행만 반환",
          "외부 조인(Outer Join): 한쪽 테이블의 모든 행을 포함하여 반환 (Left, Right, Full)",
          "교차 조인(Cross Join): 두 테이블의 모든 행을 조합하여 반환 (카티션 곱)",
          "셀프 조인(Self Join): 같은 테이블을 자기 자신과 조인",
        ],
      },
      {
        type: "subtitle",
        text: "내부 조인(Inner Join)",
      },
      {
        type: "paragraph",
        text: "내부 조인은 두 테이블에서 조인 조건을 만족하는 행만 결과에 포함합니다. 가장 많이 사용되는 조인 방식입니다.",
      },
      {
        type: "code",
        text: `SELECT S.학번, S.이름, S.학과코드, D.학과명, D.위치
FROM 학생 S
INNER JOIN 학과 D ON S.학과코드 = D.학과코드;`,
      },
      {
        type: "table",
        headers: ["학번", "이름", "학과코드", "학과명", "위치"],
        rows: [
          ["1001", "김철수", "CS", "컴퓨터공학과", "공학관 1층"],
          ["1002", "이영희", "MA", "수학과", "이학관 2층"],
          ["1003", "박지민", "CS", "컴퓨터공학과", "공학관 1층"],
        ],
        caption:
          "내부 조인 결과 (최유진 학생은 학과코드 PH가 학과 테이블에 없어서 제외됨)",
      },
      {
        type: "subtitle",
        text: "외부 조인(Outer Join)",
      },
      {
        type: "paragraph",
        text: "외부 조인은 한쪽 테이블의 모든 행을 포함하고, 다른 테이블에서 일치하는 행이 없으면 NULL 값을 채웁니다.",
      },
      {
        type: "subtitle",
        text: "좌측 외부 조인(Left Outer Join)",
      },
      {
        type: "code",
        text: `SELECT S.학번, S.이름, S.학과코드, D.학과명, D.위치
FROM 학생 S
LEFT OUTER JOIN 학과 D ON S.학과코드 = D.학과코드;`,
      },
      {
        type: "table",
        headers: ["학번", "이름", "학과코드", "학과명", "위치"],
        rows: [
          ["1001", "김철수", "CS", "컴퓨터공학과", "공학관 1층"],
          ["1002", "이영희", "MA", "수학과", "이학관 2층"],
          ["1003", "박지민", "CS", "컴퓨터공학과", "공학관 1층"],
          ["1004", "최유진", "PH", "NULL", "NULL"],
        ],
        caption: "좌측 외부 조인 결과 (학생 테이블의 모든 행 포함)",
      },
      {
        type: "subtitle",
        text: "우측 외부 조인(Right Outer Join)",
      },
      {
        type: "code",
        text: `SELECT S.학번, S.이름, D.학과코드, D.학과명, D.위치
FROM 학생 S
RIGHT OUTER JOIN 학과 D ON S.학과코드 = D.학과코드;`,
      },
      {
        type: "table",
        headers: ["학번", "이름", "학과코드", "학과명", "위치"],
        rows: [
          ["1001", "김철수", "CS", "컴퓨터공학과", "공학관 1층"],
          ["1003", "박지민", "CS", "컴퓨터공학과", "공학관 1층"],
          ["1002", "이영희", "MA", "수학과", "이학관 2층"],
          ["NULL", "NULL", "EC", "경제학과", "사회관 3층"],
        ],
        caption: "우측 외부 조인 결과 (학과 테이블의 모든 행 포함)",
      },
      {
        type: "subtitle",
        text: "완전 외부 조인(Full Outer Join)",
      },
      {
        type: "code",
        text: `SELECT S.학번, S.이름, COALESCE(S.학과코드, D.학과코드) AS 학과코드, D.학과명, D.위치
FROM 학생 S
FULL OUTER JOIN 학과 D ON S.학과코드 = D.학과코드;`,
      },
      {
        type: "table",
        headers: ["학번", "이름", "학과코드", "학과명", "위치"],
        rows: [
          ["1001", "김철수", "CS", "컴퓨터공학과", "공학관 1층"],
          ["1003", "박지민", "CS", "컴퓨터공학과", "공학관 1층"],
          ["1002", "이영희", "MA", "수학과", "이학관 2층"],
          ["1004", "최유진", "PH", "NULL", "NULL"],
          ["NULL", "NULL", "EC", "경제학과", "사회관 3층"],
        ],
        caption: "완전 외부 조인 결과 (양쪽 테이블의 모든 행 포함)",
      },
      {
        type: "subtitle",
        text: "교차 조인(Cross Join)",
      },
      {
        type: "paragraph",
        text: "교차 조인은 두 테이블의 모든 행을 조합한 결과를 반환합니다. 조인 조건이 없는 경우에 발생하며, 카티션 곱(Cartesian Product)이라고도 합니다.",
      },
      {
        type: "code",
        text: `SELECT S.이름, D.학과명
FROM 학생 S
CROSS JOIN 학과 D;`,
      },
      {
        type: "paragraph",
        text: "결과는 학생 테이블의 4행과 학과 테이블의 3행을 모두 조합한 12행(4×3)이 됩니다. 일반적으로 의도하지 않은 조인이므로 주의해야 합니다.",
      },
      {
        type: "subtitle",
        text: "셀프 조인(Self Join)",
      },
      {
        type: "paragraph",
        text: "셀프 조인은 같은 테이블을 자기 자신과 조인하는 방식입니다. 주로 계층 구조를 표현할 때 사용합니다.",
      },
      {
        type: "table",
        headers: ["사원번호", "사원명", "직급", "관리자번호"],
        rows: [
          ["E001", "김부장", "부장", "NULL"],
          ["E002", "이과장", "과장", "E001"],
          ["E003", "박대리", "대리", "E002"],
          ["E004", "최사원", "사원", "E003"],
        ],
        caption: "사원(EMPLOYEE) 테이블",
      },
      {
        type: "code",
        text: `SELECT E.사원번호, E.사원명 AS 사원, E.직급, M.사원명 AS 관리자, M.직급 AS 관리자직급
FROM 사원 E
LEFT JOIN 사원 M ON E.관리자번호 = M.사원번호;`,
      },
      {
        type: "table",
        headers: ["사원번호", "사원", "직급", "관리자", "관리자직급"],
        rows: [
          ["E001", "김부장", "부장", "NULL", "NULL"],
          ["E002", "이과장", "과장", "김부장", "부장"],
          ["E003", "박대리", "대리", "이과장", "과장"],
          ["E004", "최사원", "사원", "박대리", "대리"],
        ],
        caption: "셀프 조인 결과 (각 사원의 관리자 정보 표시)",
      },
      {
        type: "subtitle",
        text: "조인과 인덱스의 관계",
      },
      {
        type: "paragraph",
        text: "조인을 사용할 때는 조인 조건에 사용되는 컬럼에 인덱스를 생성하면 성능이 향상됩니다. 특히 대용량 테이블을 조인할 때 인덱스는 필수적입니다.",
      },
      {
        type: "paragraph",
        text: "조인은 데이터베이스에서 가장 많이 사용되는 연산 중 하나이지만, 테이블 수가 많아질수록 성능이 저하될 수 있습니다. 따라서 필요한 테이블만 조인하고, 적절한 조인 조건을 사용하는 것이 중요합니다.",
      },
    ],
  },
  "모델이 표현하는 트랜잭션의 이해": {
    title: "모델이 표현하는 트랜잭션의 이해",
    content: [
      {
        type: "paragraph",
        text: "데이터 모델은 단순히 데이터 구조만 표현하는 것이 아니라, 업무에서 발생하는 다양한 트랜잭션(Transaction)도 함께 표현합니다. 트랜잭션이란 데이터베이스에서 하나의 논리적 작업 단위를 말해요.",
      },
      {
        type: "examples",
        text: "예: 은행에서 계좌 이체는 하나의 트랜잭션으로, '출금 계좌에서 돈을 빼고, 입금 계좌에 돈을 넣는' 두 가지 작업이 모두 성공해야만 완료되는 하나의 작업입니다.",
      },
      {
        type: "subtitle",
        text: "트랜잭션의 특성 (ACID)",
      },
      {
        type: "list",
        items: [
          "원자성(Atomicity): 트랜잭션의 작업은 모두 성공하거나 모두 실패해야 함",
          "일관성(Consistency): 트랜잭션 실행 전후에 데이터베이스는 일관된 상태를 유지해야 함",
          "격리성(Isolation): 동시에 실행되는 트랜잭션들이 서로 영향을 주지 않아야 함",
          "지속성(Durability): 성공적으로 완료된 트랜잭션의 결과는 영구적으로 저장되어야 함",
        ],
      },
      {
        type: "subtitle",
        text: "데이터 모델에서 트랜잭션 표현 방법",
      },
      {
        type: "paragraph",
        text: "데이터 모델은 다음과 같은 방법으로 트랜잭션을 표현합니다.",
      },
      {
        type: "table",
        headers: ["표현 방법", "설명", "예시"],
        rows: [
          [
            "엔티티와 관계",
            "트랜잭션이 처리하는 데이터의 구조를 표현",
            "주문-주문상세-상품 관계는 '주문 처리' 트랜잭션을 지원",
          ],
          [
            "행위 엔티티",
            "트랜잭션의 결과로 생성되는 엔티티",
            "주문, 입금, 출금, 수강신청 등",
          ],
          [
            "상태 속성",
            "트랜잭션 처리 상태를 표현하는 속성",
            "주문상태(접수, 처리중, 완료), 결제상태(대기, 완료, 취소)",
          ],
          [
            "이력 엔티티",
            "트랜잭션의 이력을 저장하는 엔티티",
            "주문이력, 가격변동이력, 상태변경이력",
          ],
        ],
        caption: "데이터 모델에서 트랜잭션 표현 방법",
      },
      {
        type: "subtitle",
        text: "트랜잭션 모델링 예시 - 쇼핑몰 주문 처리",
      },
      {
        type: "paragraph",
        text: "쇼핑몰에서 고객이 상품을 주문하는 트랜잭션을 모델링해봅시다.",
      },
      {
        type: "table",
        headers: ["고객ID", "고객명", "이메일", "연락처"],
        rows: [
          ["C001", "김고객", "kim@example.com", "010-1234-5678"],
          ["C002", "이구매", "lee@example.com", "010-2345-6789"],
        ],
        caption: "고객(CUSTOMER) 테이블",
      },
      {
        type: "table",
        headers: ["상품코드", "상품명", "가격", "재고"],
        rows: [
          ["P001", "노트북", "1200000", "50"],
          ["P002", "스마트폰", "800000", "100"],
          ["P003", "이어폰", "50000", "200"],
        ],
        caption: "상품(PRODUCT) 테이블",
      },
      {
        type: "table",
        headers: ["주문번호", "고객ID", "주문일자", "주문상태", "총금액"],
        rows: [
          ["O001", "C001", "2023-05-10", "완료", "1250000"],
          ["O002", "C002", "2023-05-11", "처리중", "800000"],
        ],
        caption: "주문(ORDER) 테이블 - 행위 엔티티",
      },
      {
        type: "table",
        headers: ["주문번호", "상품코드", "수량", "단가", "금액"],
        rows: [
          ["O001", "P001", "1", "1200000", "1200000"],
          ["O001", "P003", "1", "50000", "50000"],
          ["O002", "P002", "1", "800000", "800000"],
        ],
        caption: "주문상세(ORDER_DETAIL) 테이블",
      },
      {
        type: "subtitle",
        text: "주문 처리 트랜잭션의 단계",
      },
      {
        type: "list",
        items: [
          "1. 고객이 상품을 선택하고 주문 요청",
          "2. 주문(ORDER) 레코드 생성 (주문상태: '접수')",
          "3. 주문상세(ORDER_DETAIL) 레코드 생성",
          "4. 상품(PRODUCT) 테이블의 재고 감소",
          "5. 결제 처리 후 주문상태 변경 (주문상태: '완료')",
        ],
      },
      {
        type: "subtitle",
        text: "트랜잭션을 지원하는 SQL",
      },
      {
        type: "code",
        text: `-- 트랜잭션 시작
BEGIN TRANSACTION;

-- 주문 정보 입력
INSERT INTO 주문(주문번호, 고객ID, 주문일자, 주문상태, 총금액)
VALUES('O003', 'C001', CURRENT_DATE, '접수', 1200000);

-- 주문 상세 정보 입력
INSERT INTO 주문상세(주문번호, 상품코드, 수량, 단가, 금액)
VALUES('O003', 'P001', 1, 1200000, 1200000);

-- 재고 감소
UPDATE 상품
SET 재고 = 재고 - 1
WHERE 상품코드 = 'P001';

-- 모든 작업이 성공적으로 수행되면 트랜잭션 완료
COMMIT;

-- 오류 발생 시 모든 변경사항 취소
-- ROLLBACK;`,
      },
      {
        type: "subtitle",
        text: "상태 다이어그램을 통한 트랜잭션 이해",
      },
      {
        type: "paragraph",
        text: "주문 처리 과정의 상태 변화를 다이어그램으로 표현하면 다음과 같습니다.",
      },
      {
        type: "table",
        headers: ["상태", "설명", "다음 상태"],
        rows: [
          ["접수", "주문이 시스템에 등록된 상태", "결제대기"],
          ["결제대기", "결제 처리를 기다리는 상태", "결제완료 또는 취소"],
          ["결제완료", "결제가 완료된 상태", "배송준비"],
          ["배송준비", "상품을 포장하고 출고 준비 중인 상태", "배송중"],
          ["배송중", "상품이 고객에게 배송 중인 상태", "배송완료"],
          ["배송완료", "상품이 고객에게 전달된 상태", "-"],
          ["취소", "주문이 취소된 상태", "-"],
        ],
        caption: "주문 처리의 상태 다이어그램",
      },
      {
        type: "subtitle",
        text: "이력 관리를 위한 모델링",
      },
      {
        type: "paragraph",
        text: "트랜잭션의 변화 이력을 관리하기 위해 이력 테이블을 추가할 수 있습니다.",
      },
      {
        type: "table",
        headers: [
          "이력ID",
          "주문번호",
          "변경일시",
          "이전상태",
          "변경상태",
          "처리자",
        ],
        rows: [
          ["H001", "O001", "2023-05-10 10:00:00", "NULL", "접수", "시스템"],
          ["H002", "O001", "2023-05-10 10:05:00", "접수", "결제대기", "시스템"],
          [
            "H003",
            "O001",
            "2023-05-10 10:10:00",
            "결제대기",
            "결제완료",
            "시스템",
          ],
          [
            "H004",
            "O001",
            "2023-05-10 14:00:00",
            "결제완료",
            "배송준비",
            "김직원",
          ],
          [
            "H005",
            "O001",
            "2023-05-11 09:00:00",
            "배송준비",
            "배송중",
            "이배송",
          ],
          [
            "H006",
            "O001",
            "2023-05-12 14:00:00",
            "배송중",
            "배송완료",
            "시스템",
          ],
        ],
        caption: "주문상태이력(ORDER_STATUS_HISTORY) 테이블",
      },
      {
        type: "subtitle",
        text: "트랜잭션 모델링의 이점",
      },
      {
        type: "list",
        items: [
          "데이터 정합성 유지: 관련 데이터가 모두 일관되게 처리됨",
          "업무 프로세스 파악 용이: 데이터 모델을 통해 업무 프로세스 이해 가능",
          "오류 추적 및 회복: 이력 관리를 통해 문제 발생 시 원인 파악 및 복구 가능",
          "성능 최적화: 트랜잭션 특성을 고려한 테이블 설계로 성능 향상 가능",
        ],
      },
      {
        type: "paragraph",
        text: "데이터 모델에서 트랜잭션을 적절히 표현하면 시스템의 안정성과 데이터 일관성을 유지할 수 있으며, 업무 요구사항을 더 정확하게 구현할 수 있습니다.",
      },
    ],
  },
  "NULL 속성의 이해": {
    title: "NULL 속성의 이해",
    content: [
      {
        type: "paragraph",
        text: "데이터베이스에서 NULL은 '값이 없음' 또는 '알 수 없음'을 나타내는 특별한 값입니다. NULL은 0이나 빈 문자열('')과는 다른 개념으로, 데이터 모델링과 SQL 작성 시 많은 주의가 필요합니다.",
      },
      {
        type: "examples",
        text: "예: 학생 테이블에서 휴대폰 번호가 아직 등록되지 않은 경우, 이 속성에는 NULL이 저장됩니다. 또한 직원의 퇴사일이 아직 정해지지 않았다면, 퇴사일 속성에도 NULL이 저장됩니다.",
      },
      {
        type: "subtitle",
        text: "NULL의 특성",
      },
      {
        type: "list",
        items: [
          "NULL은 '알 수 없는 값' 또는 '적용되지 않는 값'을 의미함",
          "NULL은 어떤 값과도 같지 않음 (NULL = NULL도 거짓임)",
          "NULL이 포함된 산술 연산의 결과는 NULL임",
          "NULL이 포함된 비교 연산은 UNKNOWN이라는 세 번째 논리값을 반환함",
        ],
      },
      {
        type: "subtitle",
        text: "NULL 이해를 위한 샘플 데이터",
      },
      {
        type: "table",
        headers: ["학번", "이름", "학과", "휴대폰", "동아리"],
        rows: [
          ["1001", "김철수", "컴퓨터공학", "010-1234-5678", "NULL"],
          ["1002", "이영희", "수학", "NULL", "밴드"],
          ["1003", "박지민", "물리학", "010-8765-4321", "축구"],
          ["1004", "최유진", "화학", "NULL", "NULL"],
        ],
        caption: "NULL을 포함하는 학생 테이블",
      },
      {
        type: "subtitle",
        text: "NULL과 관련된 SQL 연산",
      },
      {
        type: "paragraph",
        text: "NULL과 관련된 SQL 연산은 직관적이지 않을 수 있으므로 주의해야 합니다.",
      },
      {
        type: "subtitle",
        text: "1. 비교 연산자와 NULL",
      },
      {
        type: "code",
        text: `-- NULL과의 비교는 항상 UNKNOWN을 반환
SELECT * FROM 학생 WHERE 휴대폰 = NULL;  -- 결과 없음
SELECT * FROM 학생 WHERE 휴대폰 <> NULL; -- 결과 없음

-- NULL 비교는 IS NULL 또는 IS NOT NULL 연산자 사용
SELECT * FROM 학생 WHERE 휴대폰 IS NULL;      -- 이영희, 최유진 반환
SELECT * FROM 학생 WHERE 휴대폰 IS NOT NULL;  -- 김철수, 박지민 반환`,
      },
      {
        type: "subtitle",
        text: "2. 함수와 NULL",
      },
      {
        type: "code",
        text: `-- 집계 함수는 NULL을 무시함
SELECT COUNT(*) FROM 학생;            -- 결과: 4 (모든 행 수)
SELECT COUNT(휴대폰) FROM 학생;       -- 결과: 2 (NULL이 아닌 휴대폰 수)

-- NULL을 다른 값으로 대체하는 함수: COALESCE, NVL, IFNULL
SELECT 이름, COALESCE(휴대폰, '연락처 없음') FROM 학생;
-- Oracle: NVL(휴대폰, '연락처 없음')
-- MySQL: IFNULL(휴대폰, '연락처 없음')`,
      },
      {
        type: "subtitle",
        text: "3. 논리 연산자와 NULL",
      },
      {
        type: "paragraph",
        text: "SQL의 논리 연산은 3-값 논리(TRUE, FALSE, UNKNOWN)를 사용합니다.",
      },
      {
        type: "table",
        headers: ["연산", "결과"],
        rows: [
          ["TRUE AND UNKNOWN", "UNKNOWN"],
          ["FALSE AND UNKNOWN", "FALSE"],
          ["TRUE OR UNKNOWN", "TRUE"],
          ["FALSE OR UNKNOWN", "UNKNOWN"],
          ["NOT UNKNOWN", "UNKNOWN"],
        ],
        caption: "3-값 논리 결과표",
      },
      {
        type: "code",
        text: `-- 3-값 논리로 인한 의외의 결과
SELECT * FROM 학생 WHERE 휴대폰 = '010-1234-5678' OR 휴대폰 <> '010-1234-5678';
-- 김철수, 박지민만 반환 (NULL인 이영희, 최유진은 포함되지 않음)

-- 원하는 결과를 얻으려면 NULL 처리 필요
SELECT * FROM 학생 
WHERE 휴대폰 = '010-1234-5678' 
OR 휴대폰 <> '010-1234-5678' 
OR 휴대폰 IS NULL;`,
      },
      {
        type: "subtitle",
        text: "데이터 모델링에서 NULL 처리",
      },
      {
        type: "list",
        items: [
          "NOT NULL 제약조건: 중요한 속성은 NULL을 허용하지 않도록 설계",
          "기본값(DEFAULT) 설정: NULL 대신 의미 있는 기본값 사용",
          "외래키와 NULL: 선택적 관계에서는 외래키에 NULL 허용",
          "복합 키와 NULL: 복합 키의 일부가 NULL이면 식별 불가능",
        ],
      },
      {
        type: "table",
        headers: ["상황", "NULL 허용", "NOT NULL + 기본값", "NOT NULL 제약"],
        rows: [
          [
            "아직 값이 정해지지 않음",
            "입학예정자의 학번",
            "가입일(현재 날짜)",
            "이름(필수입력)",
          ],
          ["해당사항 없음", "미혼자의 배우자명", "할인율(0%)", "-"],
          ["알 수 없음", "연락처(미입력)", "-", "-"],
        ],
        caption: "상황별 NULL 처리 방법",
      },
      {
        type: "subtitle",
        text: "NULL 관련 주의사항",
      },
      {
        type: "list",
        items: [
          "인덱스 효율: NULL 값이 많은 컬럼에 인덱스를 생성하면 효율이 떨어짐",
          "조인 조건: 조인 컬럼에 NULL이 있으면 일치하는 행이 제외될 수 있음",
          "그룹화: NULL은 그룹화 시 하나의 그룹으로 처리됨",
          "복합 인덱스: NULL이 포함된 복합 인덱스는 일부 DBMS에서 제대로 작동하지 않을 수 있음",
        ],
      },
      {
        type: "subtitle",
        text: "NULL을 포함한 그룹화 및 정렬",
      },
      {
        type: "code",
        text: `-- 그룹화: NULL은 하나의 그룹으로 처리됨
SELECT 동아리, COUNT(*) AS 학생수
FROM 학생
GROUP BY 동아리;

-- 결과:
-- 동아리 | 학생수
-- NULL  | 2
-- 밴드   | 1
-- 축구   | 1

-- 정렬: NULL은 DBMS에 따라 처리가 다름
-- Oracle: NULL은 가장 큰 값으로 처리 (오름차순 정렬 시 마지막)
-- MySQL, SQL Server: NULL은 가장 작은 값으로 처리 (오름차순 정렬 시 처음)

-- NULL 정렬 위치 명시
SELECT 이름, 동아리
FROM 학생
ORDER BY 동아리 NULLS FIRST;  -- NULL을 처음에 정렬 (Oracle)

SELECT 이름, 동아리
FROM 학생
ORDER BY 동아리 NULLS LAST;   -- NULL을 마지막에 정렬 (Oracle)

-- MySQL, SQL Server에서는 CASE 표현식 사용
SELECT 이름, 동아리
FROM 학생
ORDER BY CASE WHEN 동아리 IS NULL THEN 1 ELSE 0 END, 동아리;  -- NULL을 처음에 정렬`,
      },
      {
        type: "subtitle",
        text: "실무에서의 NULL 처리 전략",
      },
      {
        type: "list",
        items: [
          "식별자와 필수 데이터에는 NOT NULL 제약조건 적용",
          "날짜, 수량 등 계산에 사용되는 컬럼은 기본값 설정",
          "NULL 대신 특수값 사용 고려 (예: 알 수 없는 전화번호 → '000-0000-0000')",
          "애플리케이션 레벨에서 NULL 값 검증 및 처리",
        ],
      },
      {
        type: "paragraph",
        text: "NULL은 데이터베이스에서 중요한 개념이지만, 잘못 처리하면 예상치 못한 결과를 가져올 수 있습니다. 데이터 모델링 단계에서 NULL 허용 여부를 신중하게 결정하고, SQL 작성 시 NULL 처리 방법을 정확히 이해하는 것이 중요합니다.",
      },
    ],
  },
  "본질식별자 VS 인조식별자": {
    title: "본질식별자 VS 인조식별자",
    content: [
      {
        type: "paragraph",
        text: "데이터베이스 설계에서 테이블의 기본키(Primary Key)를 선택할 때 '본질식별자'와 '인조식별자' 중 어떤 것을 사용할지는 중요한 결정입니다. 두 접근 방식은 각각 장단점이 있으며, 상황에 따라 적절한 선택이 달라집니다.",
      },
      {
        type: "subtitle",
        text: "식별자의 개념과 종류",
      },
      {
        type: "list",
        items: [
          "본질식별자(Natural Key): 업무에서 자연스럽게 발생하여 의미를 갖는 식별자",
          "인조식별자(Surrogate Key): 시스템에서 임의로 생성한 의미 없는 식별자",
        ],
      },
      {
        type: "table",
        headers: ["종류", "의미", "예시"],
        rows: [
          [
            "본질식별자",
            "업무적으로 의미가 있으며 자연스럽게 생성되는 식별자",
            "주민등록번호, ISBN, 상품코드, 학번",
          ],
          [
            "인조식별자",
            "시스템에서 생성한 임의의 값으로 업무적 의미가 없는 식별자",
            "자동증가 정수(Auto Increment), UUID, 일련번호",
          ],
        ],
        caption: "본질식별자와 인조식별자의 기본 개념",
      },
      {
        type: "subtitle",
        text: "본질식별자(Natural Key)의 특징",
      },
      {
        type: "list",
        items: [
          "업무적 의미가 있어서 직관적으로 이해하기 쉬움",
          "별도의 컬럼을 추가할 필요가 없어 저장 공간 효율적",
          "현실 세계의 개념을 그대로 데이터베이스에 반영",
          "관련 엔티티와의 관계에서 식별관계 구성 가능",
        ],
      },
      {
        type: "table",
        headers: ["장점", "단점"],
        rows: [
          [
            "업무적 의미 파악이 용이함",
            "값이 길거나 복잡할 수 있음(예: 주민등록번호)",
          ],
          [
            "추가 컬럼 없이 바로 식별자로 사용 가능",
            "업무 변경 시 식별자도 변경될 가능성 있음",
          ],
          [
            "실제 비즈니스 룰을 데이터베이스에 반영",
            "복합키로 구성되면 관리가 복잡해짐",
          ],
          [
            "데이터 모델의 직관성 향상",
            "외래키 참조 시 더 많은 저장 공간 필요",
          ],
        ],
        caption: "본질식별자의 장단점",
      },
      {
        type: "subtitle",
        text: "인조식별자(Surrogate Key)의 특징",
      },
      {
        type: "list",
        items: [
          "일반적으로 단순한 숫자나 UUID 형태로 생성됨",
          "업무 변경에 영향을 받지 않는 안정적인 구조",
          "테이블 간 조인이 간단해지고 성능이 향상될 수 있음",
          "자동 생성되므로 별도 관리가 필요 없음",
        ],
      },
      {
        type: "table",
        headers: ["장점", "단점"],
        rows: [
          [
            "값이 단순하고 인덱싱 효율이 좋음",
            "업무적 의미가 없어 직관성이 떨어짐",
          ],
          ["업무 변경에 영향을 받지 않음", "추가 컬럼으로 저장 공간 사용"],
          [
            "외래키 참조가 간단해짐",
            "원본 데이터를 확인하기 위한 추가 조회 필요",
          ],
          [
            "단일 컬럼으로 복합키 문제 해결",
            "실제 업무와 데이터 모델 간 괴리 발생",
          ],
        ],
        caption: "인조식별자의 장단점",
      },
      {
        type: "subtitle",
        text: "실제 테이블 예시 - 본질식별자",
      },
      {
        type: "paragraph",
        text: "학생 테이블에서 학번을 본질식별자로 사용한 예시",
      },
      {
        type: "table",
        headers: ["학번(PK)", "이름", "학과", "입학년도"],
        rows: [
          ["2023001", "김철수", "컴퓨터공학", "2023"],
          ["2023002", "이영희", "수학", "2023"],
          ["2022001", "박지민", "물리학", "2022"],
        ],
        caption: "본질식별자(학번)를 사용한 학생 테이블",
      },
      {
        type: "table",
        headers: ["학번(FK)", "과목코드", "학년도", "학기", "성적"],
        rows: [
          ["2023001", "CS101", "2023", "1", "A+"],
          ["2023001", "MA101", "2023", "1", "B+"],
          ["2023002", "MA101", "2023", "1", "A"],
        ],
        caption: "본질식별자를 참조하는 수강내역 테이블",
      },
      {
        type: "subtitle",
        text: "실제 테이블 예시 - 인조식별자",
      },
      {
        type: "paragraph",
        text: "학생 테이블에서 자동 증가 ID를 인조식별자로 사용한 예시",
      },
      {
        type: "table",
        headers: ["ID(PK)", "학번", "이름", "학과", "입학년도"],
        rows: [
          ["1", "2023001", "김철수", "컴퓨터공학", "2023"],
          ["2", "2023002", "이영희", "수학", "2023"],
          ["3", "2022001", "박지민", "물리학", "2022"],
        ],
        caption: "인조식별자(ID)를 사용한 학생 테이블",
      },
      {
        type: "table",
        headers: ["ID(PK)", "학생ID(FK)", "과목코드", "학년도", "학기", "성적"],
        rows: [
          ["1", "1", "CS101", "2023", "1", "A+"],
          ["2", "1", "MA101", "2023", "1", "B+"],
          ["3", "2", "MA101", "2023", "1", "A"],
        ],
        caption: "인조식별자를 참조하는 수강내역 테이블",
      },
      {
        type: "subtitle",
        text: "식별관계와 비식별관계",
      },
      {
        type: "paragraph",
        text: "식별자 선택은 테이블 간의 관계 유형에도 영향을 미칩니다.",
      },
      {
        type: "table",
        headers: ["관계 유형", "정의", "특징", "예시"],
        rows: [
          [
            "식별관계",
            "부모 테이블의 기본키가 자식 테이블의 기본키이자 외래키가 됨",
            "강한 연관성, 종속적인 관계를 표현",
            "주문-주문상세(주문번호가 주문상세의 PK 일부)",
          ],
          [
            "비식별관계",
            "부모 테이블의 기본키가 자식 테이블의 일반 속성으로 참조됨",
            "약한 연관성, 독립적인 관계를 표현",
            "부서-사원(부서번호가 사원 테이블의 일반 속성)",
          ],
        ],
        caption: "식별관계와 비식별관계 비교",
      },
      {
        type: "subtitle",
        text: "본질식별자와 인조식별자 선택 기준",
      },
      {
        type: "list",
        items: [
          "테이블의 특성과 용도: 트랜잭션 테이블은 인조식별자가 유리할 수 있음",
          "성능 요구사항: 대용량 테이블은 단순한 인조식별자가 유리",
          "데이터 통합 요구사항: 여러 시스템 연계 시 본질식별자가 도움이 될 수 있음",
          "업무 규칙의 안정성: 빈번한 변경이 예상되면 인조식별자 고려",
        ],
      },
      {
        type: "table",
        headers: ["상황", "권장 식별자", "이유"],
        rows: [
          [
            "업무적으로 이미 식별자가 확립됨",
            "본질식별자",
            "기존 업무 흐름과 일치, 직관적 이해 가능",
          ],
          [
            "대용량 데이터 처리 필요",
            "인조식별자",
            "단순 정수형으로 인덱싱 효율 높음",
          ],
          [
            "식별자가 자주 변경될 가능성",
            "인조식별자",
            "업무 변경에 영향받지 않는 안정적 구조",
          ],
          [
            "여러 시스템 통합 환경",
            "상황에 따라 다름",
            "시스템 간 통합 요구사항 고려 필요",
          ],
        ],
        caption: "상황별 식별자 선택 가이드",
      },
      {
        type: "subtitle",
        text: "실무 사례 분석",
      },
      {
        type: "paragraph",
        text: "인터넷 쇼핑몰 데이터베이스의 식별자 선택 예시",
      },
      {
        type: "table",
        headers: ["테이블", "본질식별자 사용", "인조식별자 사용", "권장"],
        rows: [
          [
            "고객",
            "이메일(중복 가능성 낮음)",
            "고객ID(자동증가)",
            "인조식별자(개인정보 보호, 변경 가능성)",
          ],
          [
            "상품",
            "상품코드(체계적 관리 가능)",
            "상품ID(자동증가)",
            "본질식별자(업무에서 이미 사용 중인 코드)",
          ],
          [
            "주문",
            "주문번호(업무규칙 반영)",
            "주문ID(자동증가)",
            "상황에 따라 다름(주문번호 체계에 따라)",
          ],
          [
            "주문상세",
            "주문번호+상품코드(복합키)",
            "주문상세ID(자동증가)",
            "인조식별자(복합키 관리 복잡성 해소)",
          ],
        ],
        caption: "쇼핑몰 데이터베이스의 식별자 선택 예시",
      },
      {
        type: "subtitle",
        text: "결론",
      },
      {
        type: "paragraph",
        text: "본질식별자와 인조식별자는 각각 장단점이 있으며, 어느 것이 더 좋은지는 상황에 따라 다릅니다. 데이터베이스 설계 시 업무 특성, 성능 요구사항, 유지보수 용이성 등을 종합적으로 고려하여 식별자를 선택해야 합니다. 또한 일부 테이블에는 본질식별자를, 다른 테이블에는 인조식별자를 사용하는 혼합 접근 방식도 가능합니다.",
      },
      {
        type: "paragraph",
        text: "최근에는 많은 시스템에서 인조식별자를 선호하는 경향이 있지만, 업무 규칙이 명확하고 안정적인 경우에는 본질식별자도 여전히 유효한 선택입니다. 중요한 것은 프로젝트의 요구사항과 특성에 맞게 적절한 식별자를 선택하는 것입니다.",
      },
    ],
  },
  // SQL 기본
  "관계형 데이터베이스 개요": {
    title: "관계형 데이터베이스 개요",
    content: [
      {
        type: "paragraph",
        text: "관계형 데이터베이스(Relational Database)는 테이블 형태로 데이터를 저장하고, 테이블 간의 관계를 이용해 데이터를 관리하는 데이터베이스 시스템입니다. 오늘날 가장 널리 사용되는 데이터베이스 유형입니다.",
      },
      {
        type: "examples",
        text: "우리가 일상에서 사용하는 대부분의 서비스(인터넷 쇼핑몰, 학교 성적 관리, 은행 거래 시스템 등)는 관계형 데이터베이스를 사용하고 있어요.",
      },
      {
        type: "subtitle",
        text: "관계형 데이터베이스의 특징",
      },
      {
        type: "list",
        items: [
          "데이터를 테이블(행과 열)로 구성: 직관적이고 이해하기 쉬운 구조",
          "여러 테이블 간의 관계를 통해 데이터 참조 가능",
          "SQL(Structured Query Language)을 사용하여 데이터 조작",
          "ACID 특성(원자성, 일관성, 격리성, 지속성)을 보장하여 데이터 신뢰성 확보",
          "데이터의 중복을 최소화하고 무결성을 유지하는 정규화 기법 적용",
        ],
      },
      {
        type: "subtitle",
        text: "관계형 데이터베이스의 기본 용어",
      },
      {
        type: "table",
        headers: ["용어", "설명", "예시"],
        rows: [
          [
            "테이블(Table)",
            "데이터를 저장하는 기본 단위, 행과 열로 구성됨",
            "학생 테이블, 상품 테이블",
          ],
          [
            "행(Row)/레코드(Record)",
            "테이블의 가로줄, 하나의 데이터 단위",
            "하나의 학생 정보, 하나의 주문 정보",
          ],
          [
            "열(Column)/필드(Field)",
            "테이블의 세로줄, 특정 속성을 나타냄",
            "이름, 학번, 전화번호",
          ],
          [
            "기본키(Primary Key)",
            "각 행을 고유하게 식별하는 열 또는 열의 조합",
            "학번, 주문번호, 사원번호",
          ],
          [
            "외래키(Foreign Key)",
            "다른 테이블의 기본키를 참조하는 열",
            "학생 테이블의 학과코드(학과 테이블 참조)",
          ],
          [
            "스키마(Schema)",
            "데이터베이스의 구조와 제약조건 정의",
            "테이블 구조, 관계, 규칙의 집합",
          ],
        ],
        caption: "관계형 데이터베이스의 주요 용어",
      },
      {
        type: "subtitle",
        text: "주요 관계형 데이터베이스 관리 시스템(RDBMS)",
      },
      {
        type: "table",
        headers: ["RDBMS", "개발사", "특징"],
        rows: [
          [
            "Oracle",
            "Oracle Corporation",
            "대규모 기업용 DBMS, 높은 안정성과 성능, 고가의 라이선스",
          ],
          [
            "MySQL",
            "Oracle Corporation (이전 MySQL AB)",
            "오픈 소스 DBMS, 웹 애플리케이션에 많이 사용, 빠른 읽기 성능",
          ],
          [
            "SQL Server",
            "Microsoft",
            "윈도우 환경에 최적화, MS 제품과 잘 통합됨",
          ],
          [
            "PostgreSQL",
            "PostgreSQL Global Development Group",
            "오픈 소스 DBMS, 고급 기능 지원, 복잡한 쿼리에 강점",
          ],
          [
            "SQLite",
            "D. Richard Hipp",
            "파일 기반 경량 DBMS, 내장형 애플리케이션에 적합",
          ],
        ],
        caption: "주요 관계형 데이터베이스 관리 시스템 비교",
      },
      {
        type: "subtitle",
        text: "SQL 개요",
      },
      {
        type: "paragraph",
        text: "SQL(Structured Query Language)은 관계형 데이터베이스를 관리하고 데이터를 조작하기 위한 표준 언어입니다. SQL은 크게 다음과 같은 범주로 나눌 수 있습니다.",
      },
      {
        type: "table",
        headers: ["분류", "역할", "주요 명령어"],
        rows: [
          ["DQL (Data Query Language)", "데이터 조회", "SELECT (데이터 조회)"],
          [
            "DML (Data Manipulation Language)",
            "데이터 조작",
            "INSERT (삽입), UPDATE (수정), DELETE (삭제)",
          ],
          [
            "DDL (Data Definition Language)",
            "데이터 정의",
            "CREATE (생성), ALTER (변경), DROP (삭제), TRUNCATE (비우기)",
          ],
          [
            "DCL (Data Control Language)",
            "데이터 제어",
            "GRANT (권한 부여), REVOKE (권한 회수)",
          ],
          [
            "TCL (Transaction Control Language)",
            "트랜잭션 제어",
            "COMMIT (확정), ROLLBACK (취소), SAVEPOINT (저장점 생성)",
          ],
        ],
        caption: "SQL 명령어 분류",
      },
      {
        type: "subtitle",
        text: "관계형 데이터베이스의 장단점",
      },
      {
        type: "table",
        headers: ["장점", "단점"],
        rows: [
          [
            "데이터의 일관성과 정확성 보장",
            "대용량 데이터 처리 시 성능 저하 가능",
          ],
          ["표준화된 SQL을 통한 접근 용이", "수평적 확장(Scale-out)이 어려움"],
          [
            "복잡한 쿼리와 트랜잭션 처리 가능",
            "유연하지 않은 스키마 구조 (변경 비용 높음)",
          ],
          [
            "데이터 중복 최소화로 저장 공간 절약",
            "객체 지향 프로그래밍과의 임피던스 불일치",
          ],
          ["데이터 무결성과 보안 강화", "비정형 데이터 처리에 불리함"],
        ],
        caption: "관계형 데이터베이스의 장단점",
      },
      {
        type: "subtitle",
        text: "관계형 모델의 발전",
      },
      {
        type: "paragraph",
        text: "관계형 데이터베이스는 1970년 E.F. Codd가 관계 모델을 제안하면서 시작되었습니다. 이후 수십 년 동안 발전하여 현재 데이터 관리의 표준이 되었습니다. 최근에는 빅데이터, 실시간 처리, 비정형 데이터 등의 요구사항에 대응하기 위해 NoSQL, NewSQL 등 새로운 데이터베이스 모델도 등장했지만, 여전히 많은 시스템에서 관계형 데이터베이스는 핵심적인 역할을 수행하고 있습니다.",
      },
      {
        type: "subtitle",
        text: "관계형 데이터베이스 예시 - 학교 데이터베이스",
      },
      {
        type: "table",
        headers: ["학번", "이름", "학과코드", "학년", "생년월일"],
        rows: [
          ["2023001", "김철수", "CS", "1", "2004-05-10"],
          ["2023002", "이영희", "MA", "1", "2004-08-15"],
          ["2022001", "박지민", "CS", "2", "2003-01-22"],
          ["2022002", "최유진", "PH", "2", "2003-11-07"],
        ],
        caption: "학생(STUDENT) 테이블",
      },
      {
        type: "table",
        headers: ["학과코드", "학과명", "위치", "전화번호"],
        rows: [
          ["CS", "컴퓨터공학과", "공학관 1층", "02-1234-5678"],
          ["MA", "수학과", "이학관 2층", "02-1234-5679"],
          ["PH", "물리학과", "이학관 3층", "02-1234-5680"],
        ],
        caption: "학과(DEPARTMENT) 테이블",
      },
      {
        type: "table",
        headers: ["과목코드", "과목명", "학점", "담당교수"],
        rows: [
          ["CS101", "프로그래밍 기초", "3", "김교수"],
          ["CS102", "자료구조", "3", "박교수"],
          ["MA101", "미적분학", "3", "이교수"],
          ["PH101", "일반물리학", "3", "최교수"],
        ],
        caption: "과목(COURSE) 테이블",
      },
      {
        type: "table",
        headers: ["수강번호", "학번", "과목코드", "년도", "학기", "성적"],
        rows: [
          ["1", "2023001", "CS101", "2023", "1", "A+"],
          ["2", "2023001", "MA101", "2023", "1", "B+"],
          ["3", "2023002", "MA101", "2023", "1", "A"],
          ["4", "2022001", "CS102", "2023", "1", "A"],
        ],
        caption: "수강(ENROLLMENT) 테이블",
      },
      {
        type: "paragraph",
        text: "위의 테이블들은 관계를 통해 연결되어 있습니다. 예를 들어, 학생 테이블의 '학과코드'는 학과 테이블의 '학과코드'를 참조하는 외래키이며, 수강 테이블의 '학번'과 '과목코드'는 각각 학생 테이블과 과목 테이블을 참조하는 외래키입니다. 이러한 관계를 통해 '김철수 학생이 수강 중인 모든 과목 조회', '컴퓨터공학과 학생들의 평균 성적 계산' 등의 복잡한 정보를 추출할 수 있습니다.",
      },
    ],
  },
  함수: {
    title: "SQL 함수 (Functions)",
    content: [
      {
        type: "paragraph",
        text: "SQL 함수는 데이터베이스에서 데이터를 처리하고 변환하는 데 사용되는 내장 기능입니다. 함수를 사용하면 복잡한 계산, 문자열 조작, 날짜 처리 등을 간단하게 수행할 수 있습니다.",
      },
      {
        type: "examples",
        text: "예: 학생들의 평균 성적을 계산하거나(AVG 함수), 이름의 첫 글자만 대문자로 변환하거나(INITCAP 함수), 오늘 날짜로부터 30일 후의 날짜를 계산하는 등(ADD_MONTHS 함수)의 작업을 함수로 쉽게 처리할 수 있습니다.",
      },
      {
        type: "subtitle",
        text: "SQL 함수의 종류",
      },
      {
        type: "list",
        items: [
          "단일행 함수(Single-Row Functions): 입력 행마다 하나의 결과를 반환",
          "집계 함수(Aggregate Functions): 여러 행의 값을 그룹화하여 하나의 결과를 반환",
          "분석 함수(Analytic Functions): 집계와 유사하지만 행 단위 처리가 가능한 함수",
          "윈도우 함수(Window Functions): 행들의 그룹(윈도우)에 대한 계산을 수행하는 함수",
        ],
      },
      {
        type: "subtitle",
        text: "1. 단일행 함수 (Single-Row Functions)",
      },
      {
        type: "paragraph",
        text: "단일행 함수는 각 행에 대해 하나의 결과를 반환합니다. 주요 단일행 함수는 다음과 같습니다.",
      },
      {
        type: "subtitle",
        text: "1.1 문자 함수",
      },
      {
        type: "table",
        headers: ["함수", "설명", "예시", "결과"],
        rows: [
          [
            "UPPER(문자열)",
            "모든 문자를 대문자로 변환",
            "UPPER('Hello')",
            "HELLO",
          ],
          [
            "LOWER(문자열)",
            "모든 문자를 소문자로 변환",
            "LOWER('Hello')",
            "hello",
          ],
          [
            "SUBSTR(문자열, 위치, 길이)",
            "지정된 위치에서 지정된 길이만큼 문자열 추출",
            "SUBSTR('HELLO', 2, 3)",
            "ELL",
          ],
          ["LENGTH(문자열)", "문자열의 길이를 반환", "LENGTH('HELLO')", "5"],
          [
            "TRIM(문자열)",
            "문자열 앞뒤의 공백 제거",
            "TRIM(' HELLO ')",
            "HELLO",
          ],
          [
            "CONCAT(문자열1, 문자열2)",
            "두 문자열을 연결",
            "CONCAT('Hello', 'World')",
            "HelloWorld",
          ],
          [
            "REPLACE(문자열, 찾을 문자열, 대체 문자열)",
            "문자열에서 특정 부분을 다른 문자열로 대체",
            "REPLACE('HELLO', 'LL', 'XX')",
            "HEXXO",
          ],
        ],
        caption: "주요 문자 함수",
      },
      {
        type: "subtitle",
        text: "1.2 숫자 함수",
      },
      {
        type: "table",
        headers: ["함수", "설명", "예시", "결과"],
        rows: [
          ["ABS(숫자)", "절대값 반환", "ABS(-15)", "15"],
          [
            "ROUND(숫자, 자릿수)",
            "지정한 자릿수로 반올림",
            "ROUND(123.456, 1)",
            "123.5",
          ],
          [
            "TRUNC(숫자, 자릿수)",
            "지정한 자릿수로 절사",
            "TRUNC(123.456, 1)",
            "123.4",
          ],
          [
            "CEIL(숫자)",
            "숫자보다 크거나 같은 최소 정수",
            "CEIL(123.456)",
            "124",
          ],
          [
            "FLOOR(숫자)",
            "숫자보다 작거나 같은 최대 정수",
            "FLOOR(123.456)",
            "123",
          ],
          [
            "MOD(숫자1, 숫자2)",
            "숫자1을 숫자2로 나눈 나머지",
            "MOD(10, 3)",
            "1",
          ],
          ["POWER(숫자1, 숫자2)", "숫자1의 숫자2승", "POWER(2, 3)", "8"],
        ],
        caption: "주요 숫자 함수",
      },
      {
        type: "subtitle",
        text: "1.3 날짜 함수",
      },
      {
        type: "table",
        headers: ["함수", "설명", "예시", "결과 (예시)"],
        rows: [
          [
            "SYSDATE 또는 CURRENT_DATE",
            "현재 날짜 반환",
            "SYSDATE",
            "2023-05-15",
          ],
          [
            "ADD_MONTHS(날짜, 개월 수)",
            "날짜에 개월 수를 더함",
            "ADD_MONTHS('2023-05-15', 3)",
            "2023-08-15",
          ],
          [
            "MONTHS_BETWEEN(날짜1, 날짜2)",
            "두 날짜 사이의 개월 수 계산",
            "MONTHS_BETWEEN('2023-05-15', '2023-02-15')",
            "3",
          ],
          [
            "LAST_DAY(날짜)",
            "해당 월의 마지막 날짜",
            "LAST_DAY('2023-02-15')",
            "2023-02-28",
          ],
          [
            "EXTRACT(요소 FROM 날짜)",
            "날짜에서 특정 요소(년, 월, 일 등) 추출",
            "EXTRACT(YEAR FROM '2023-05-15')",
            "2023",
          ],
          [
            "TO_DATE(문자열, 형식)",
            "문자열을 날짜로 변환",
            "TO_DATE('2023-05-15', 'YYYY-MM-DD')",
            "2023-05-15 (날짜형)",
          ],
          [
            "TO_CHAR(날짜, 형식)",
            "날짜를 지정한 형식의 문자열로 변환",
            "TO_CHAR(SYSDATE, 'YYYY-MM-DD')",
            "2023-05-15 (문자형)",
          ],
        ],
        caption: "주요 날짜 함수",
      },
      {
        type: "subtitle",
        text: "1.4 변환 함수",
      },
      {
        type: "table",
        headers: ["함수", "설명", "예시", "결과"],
        rows: [
          [
            "TO_CHAR(값, 형식)",
            "숫자 또는 날짜를 문자열로 변환",
            "TO_CHAR(1234.56, '9,999.99')",
            "1,234.56",
          ],
          [
            "TO_NUMBER(문자열)",
            "문자열을 숫자로 변환",
            "TO_NUMBER('1234.56')",
            "1234.56",
          ],
          [
            "TO_DATE(문자열, 형식)",
            "문자열을 날짜로 변환",
            "TO_DATE('2023-05-15', 'YYYY-MM-DD')",
            "2023-05-15 (날짜형)",
          ],
          [
            "CAST(값 AS 데이터타입)",
            "값을 지정한 데이터 타입으로 변환",
            "CAST('123' AS INTEGER)",
            "123 (정수형)",
          ],
        ],
        caption: "주요 변환 함수",
      },
      {
        type: "subtitle",
        text: "1.5 NULL 관련 함수",
      },
      {
        type: "table",
        headers: ["함수", "설명", "예시", "결과"],
        rows: [
          [
            "NVL(값1, 값2) 또는 IFNULL/COALESCE",
            "값1이 NULL이면 값2 반환, 아니면 값1 반환",
            "NVL(NULL, '대체값')",
            "대체값",
          ],
          [
            "NULLIF(값1, 값2)",
            "값1과 값2가 같으면 NULL 반환, 다르면 값1 반환",
            "NULLIF('A', 'A')",
            "NULL",
          ],
          [
            "COALESCE(값1, 값2, ...)",
            "NULL이 아닌 첫 번째 값 반환",
            "COALESCE(NULL, NULL, '값', NULL)",
            "값",
          ],
        ],
        caption: "주요 NULL 관련 함수",
      },
      {
        type: "subtitle",
        text: "1.6 조건 함수",
      },
      {
        type: "table",
        headers: ["함수", "설명", "예시", "결과"],
        rows: [
          [
            "CASE WHEN 조건1 THEN 결과1 WHEN 조건2 THEN 결과2 ELSE 기본결과 END",
            "여러 조건에 따라 다른 결과 반환",
            "CASE WHEN 점수 >= 90 THEN 'A' WHEN 점수 >= 80 THEN 'B' ELSE 'C' END",
            "조건에 따라 'A', 'B', 또는 'C'",
          ],
          [
            "DECODE(컬럼, 값1, 결과1, 값2, 결과2, ..., 기본결과)",
            "컬럼 값에 따라 다른 결과 반환(Oracle 전용)",
            "DECODE(성별, 'M', '남성', 'F', '여성', '기타')",
            "성별 값에 따라 '남성', '여성', 또는 '기타'",
          ],
        ],
        caption: "주요 조건 함수",
      },
      {
        type: "subtitle",
        text: "2. 집계 함수 (Aggregate Functions)",
      },
      {
        type: "paragraph",
        text: "집계 함수는 여러 행의 값을 그룹화하여 하나의 결과를 반환합니다. 주로 GROUP BY 절과 함께 사용됩니다.",
      },
      {
        type: "table",
        headers: ["함수", "설명", "예시"],
        rows: [
          ["COUNT(컬럼 또는 *)", "행의 수를 계산", "COUNT(*) FROM 학생"],
          ["SUM(컬럼)", "합계 계산", "SUM(성적) FROM 수강"],
          ["AVG(컬럼)", "평균 계산", "AVG(성적) FROM 수강"],
          ["MAX(컬럼)", "최대값 반환", "MAX(성적) FROM 수강"],
          ["MIN(컬럼)", "최소값 반환", "MIN(성적) FROM 수강"],
          ["STDDEV(컬럼)", "표준편차 계산", "STDDEV(성적) FROM 수강"],
          ["VARIANCE(컬럼)", "분산 계산", "VARIANCE(성적) FROM 수강"],
        ],
        caption: "주요 집계 함수",
      },
      {
        type: "code",
        text: `-- 학과별 학생 수와 평균 학년 조회
SELECT 학과코드, COUNT(*) AS 학생수, AVG(학년) AS 평균학년
FROM 학생
GROUP BY 학과코드;

-- 학과별, 학년별 학생 수 조회
SELECT 학과코드, 학년, COUNT(*) AS 학생수
FROM 학생
GROUP BY 학과코드, 학년
ORDER BY 학과코드, 학년;

-- 각 과목별 최고 성적과 최저 성적 조회
SELECT 과목코드, MAX(성적) AS 최고성적, MIN(성적) AS 최저성적
FROM 수강
GROUP BY 과목코드;`,
      },
      {
        type: "subtitle",
        text: "3. 분석 함수(Analytic Functions)와 윈도우 함수(Window Functions)",
      },
      {
        type: "paragraph",
        text: "분석 함수와 윈도우 함수는 집계 함수와 유사하지만, 결과를 그룹당 하나가 아닌 각 행에 대해 반환합니다. 이를 통해 행 단위 처리와 그룹 단위 집계를 동시에 수행할 수 있습니다.",
      },
      {
        type: "table",
        headers: ["함수", "설명", "예시"],
        rows: [
          [
            "ROW_NUMBER()",
            "결과 집합의 각 행에 고유한 순번 부여",
            "ROW_NUMBER() OVER(ORDER BY 성적 DESC)",
          ],
          [
            "RANK()",
            "동일한 값에 대해 동일한 순위 부여(건너뛰기 포함)",
            "RANK() OVER(ORDER BY 성적 DESC)",
          ],
          [
            "DENSE_RANK()",
            "동일한 값에 대해 동일한 순위 부여(건너뛰기 없음)",
            "DENSE_RANK() OVER(ORDER BY 성적 DESC)",
          ],
          [
            "NTILE(n)",
            "결과를 n개의 그룹으로 균등하게 분할",
            "NTILE(4) OVER(ORDER BY 성적 DESC)",
          ],
          [
            "LAG(컬럼, n)",
            "현재 행에서 n행 이전의 값 반환",
            "LAG(성적, 1) OVER(ORDER BY 학번)",
          ],
          [
            "LEAD(컬럼, n)",
            "현재 행에서 n행 이후의 값 반환",
            "LEAD(성적, 1) OVER(ORDER BY 학번)",
          ],
          [
            "SUM() OVER()",
            "누적 합계 또는 윈도우 합계 계산",
            "SUM(성적) OVER(PARTITION BY 과목코드 ORDER BY 학번)",
          ],
        ],
        caption: "주요 분석 함수와 윈도우 함수",
      },
      {
        type: "code",
        text: `-- 성적 순위 부여
SELECT 학번, 과목코드, 성적,
       RANK() OVER(ORDER BY 성적 DESC) AS 전체순위,
       RANK() OVER(PARTITION BY 과목코드 ORDER BY 성적 DESC) AS 과목내순위
FROM 수강;

-- 학번별 성적 누적 합계
SELECT 학번, 과목코드, 성적,
       SUM(성적) OVER(PARTITION BY 학번 ORDER BY 과목코드) AS 누적성적
FROM 수강;

-- 이전 학기와 다음 학기 성적 비교
SELECT 학번, 년도, 학기, AVG(성적) AS 평균성적,
       LAG(AVG(성적)) OVER(PARTITION BY 학번 ORDER BY 년도, 학기) AS 이전학기성적,
       LEAD(AVG(성적)) OVER(PARTITION BY 학번 ORDER BY 년도, 학기) AS 다음학기성적
FROM 수강
GROUP BY 학번, 년도, 학기;`,
      },
      {
        type: "subtitle",
        text: "함수 사용 시 주의사항",
      },
      {
        type: "list",
        items: [
          "데이터베이스 시스템마다 지원하는 함수가 다를 수 있음",
          "동일한 기능의 함수라도 이름이나 사용법이 다를 수 있음 (예: Oracle의 NVL vs. MySQL의 IFNULL)",
          "함수 중첩 사용 시 안쪽에서 바깥쪽 순서로 실행됨",
          "NULL 값을 포함한 연산은 결과가 NULL이 되므로, NULL 처리 함수를 적절히 사용해야 함",
          "대용량 데이터에 복잡한 함수를 사용하면 성능 저하가 발생할 수 있음",
        ],
      },
      {
        type: "subtitle",
        text: "실제 활용 예시",
      },
      {
        type: "code",
        text: `-- 학생 이름을 '성, 이름' 형식으로 변환
SELECT 학번, CONCAT(SUBSTR(이름, 1, 1), ', ', SUBSTR(이름, 2)) AS 변환이름
FROM 학생;

-- 오늘 날짜 기준으로 학생 나이 계산
SELECT 학번, 이름, 생년월일,
       EXTRACT(YEAR FROM CURRENT_DATE) - EXTRACT(YEAR FROM 생년월일) AS 나이
FROM 학생;

-- 성적을 등급으로 변환
SELECT 학번, 과목코드, 성적,
       CASE
         WHEN 성적 >= 90 THEN 'A'
         WHEN 성적 >= 80 THEN 'B'
         WHEN 성적 >= 70 THEN 'C'
         WHEN 성적 >= 60 THEN 'D'
         ELSE 'F'
       END AS 성적등급
FROM 수강;

-- 학과별 평균 성적과 전체 평균의 차이 계산
SELECT 학과.학과코드, 학과.학과명,
       AVG(수강.성적) AS 학과평균,
       (SELECT AVG(성적) FROM 수강) AS 전체평균,
       AVG(수강.성적) - (SELECT AVG(성적) FROM 수강) AS 차이
FROM 학과
JOIN 학생 ON 학과.학과코드 = 학생.학과코드
JOIN 수강 ON 학생.학번 = 수강.학번
GROUP BY 학과.학과코드, 학과.학과명;`,
      },
      {
        type: "paragraph",
        text: "SQL 함수를 올바르게 사용하면 복잡한 데이터 처리와 분석 작업을 효율적으로 수행할 수 있습니다. 특히 단일행 함수와 집계 함수를 조합하여 사용하면 다양한 비즈니스 요구사항을 충족시킬 수 있습니다. 함수마다 특성과 사용법이 다르므로, 문제 해결에 적합한 함수를 선택하는 것이 중요합니다.",
      },
    ],
  },

  "SELECT 문": {
    title: "SELECT 문",
    content: [
      {
        type: "paragraph",
        text: "SELECT 문은 관계형 데이터베이스에서 데이터를 조회하는 기본 SQL 문입니다. 어떤 데이터를, 어떤 조건으로, 어떤 방식으로 조회할지 지정하는 역할을 하며, SQLD 시험에서도 핵심 개념 중 하나입니다.",
      },
      {
        type: "subtitle",
        text: "학생 테이블 예시 데이터",
      },
      {
        type: "table",
        headers: ["학번", "이름", "학과코드", "학년"],
        rows: [
          [101, "김철수", "CS", 2],
          [102, "이영희", "CS", 3],
          [103, "박민수", "EE", 1],
          [104, "최수진", "CS", 2],
          [105, "정다은", "ME", 4],
          [106, "한지훈", "EE", 2],
          [107, "오세훈", "ME", 1],
        ],
        caption: "학생 테이블 예시 데이터",
      },
      {
        type: "subtitle",
        text: "기본 SELECT 문 예시 - 특정 컬럼 조회",
      },
      {
        type: "code",
        text: "SELECT 이름, 학과코드 FROM 학생;",
      },
      {
        type: "table",
        headers: ["이름", "학과코드"],
        rows: [
          ["김철수", "CS"],
          ["이영희", "CS"],
          ["박민수", "EE"],
          ["최수진", "CS"],
          ["정다은", "ME"],
          ["한지훈", "EE"],
          ["오세훈", "ME"],
        ],
        caption: "SELECT 이름, 학과코드 조회 결과",
      },
      {
        type: "subtitle",
        text: "SELECT 문의 기본 구조",
      },
      {
        type: "code",
        text: "SELECT [DISTINCT] 컬럼명 [AS 별칭], ...\nFROM 테이블명\n[WHERE 조건식]\n[GROUP BY 컬럼명]\n[HAVING 조건식]\n[ORDER BY 컬럼명 [ASC|DESC]];",
      },
      {
        type: "subtitle",
        text: "SELECT 문의 실행 순서와 주요 절 설명",
      },
      {
        type: "list",
        items: [
          "FROM: 데이터를 가져올 테이블을 지정합니다.",
          "WHERE: 행 단위 조건을 필터링합니다. (다음 컨텐츠에서 자세히 다룹니다)",
          "GROUP BY: 데이터를 그룹으로 묶습니다. (다음 컨텐츠에서 자세히 다룹니다)",
          "HAVING: 그룹화된 결과에 조건을 걸어 필터링합니다. (다음 컨텐츠에서 자세히 다룹니다)",
          "SELECT: 조회할 컬럼과 집계 함수를 지정합니다.",
          "DISTINCT: 중복된 행을 제거합니다.",
          "ORDER BY: 결과를 정렬합니다. (다음 컨텐츠에서 자세히 다룹니다)",
        ],
      },
      {
        type: "subtitle",
        text: "SELECT 문의 주요 절 역할 요약",
      },
      {
        type: "table",
        headers: ["절", "역할", "비고"],
        rows: [
          [
            "SELECT",
            "조회할 컬럼 및 집계 함수 지정",
            "별칭(AS), DISTINCT 사용 가능",
          ],
          ["FROM", "데이터를 가져올 테이블 지정", "테이블 별칭 사용 가능"],
          [
            "WHERE",
            "행 단위 조건 필터링",
            "집계 함수 조건 불가, 다음 컨텐츠 참고",
          ],
          [
            "GROUP BY",
            "데이터를 그룹으로 묶음",
            "GROUP BY 대상 컬럼은 SELECT에도 포함, 다음 컨텐츠 참고",
          ],
          [
            "HAVING",
            "그룹화 결과 조건 필터링",
            "집계 함수 조건 가능, 다음 컨텐츠 참고",
          ],
          [
            "ORDER BY",
            "결과 정렬",
            "ASC(오름차순) / DESC(내림차순), 다음 컨텐츠 참고",
          ],
        ],
        caption: "SELECT 문의 주요 절 역할",
      },
      {
        type: "subtitle",
        text: "SELECT 문 작성 팁",
      },
      {
        type: "list",
        items: [
          "필요한 컬럼만 명시하여 조회 성능을 높이세요.",
          "WHERE 절을 활용해 데이터를 먼저 필터링하면 효율적입니다.",
          "GROUP BY와 HAVING 절의 사용 순서를 지키세요.",
          "ORDER BY 절은 결과 정렬을 위해 마지막에 사용됩니다.",
          "별칭은 AS로 명확히 지정하면 가독성이 좋아집니다.",
        ],
      },
      {
        type: "paragraph",
        text: "SELECT 문은 데이터 조회의 핵심입니다. 각 절의 역할과 실행 순서를 이해하면 복잡한 쿼리도 쉽게 작성할 수 있습니다.",
      },
    ],
  },
  "WHERE 절": {
    title: "WHERE 절 (WHERE Clause)",
    content: [
      {
        type: "paragraph",
        text: "SQL에서 WHERE 절은 조건에 맞는 행(row)만 조회하거나 수정, 삭제할 때 사용하는 필터 역할을 합니다. SELECT, UPDATE, DELETE 문에서 자주 사용되며, 조건을 설정하지 않으면 전체 데이터가 대상이 돼요.",
      },
      {
        type: "examples",
        text: "예를 들어, 학생 테이블에서 이름이 '김철수'인 학생만 조회하고 싶다면 WHERE 절을 사용해서 해당 조건을 명시해야 합니다.",
      },
      {
        type: "subtitle",
        text: "기본 사용법",
      },
      {
        type: "code",
        language: "sql",
        text: "SELECT * FROM 학생 WHERE 이름 = '김철수';",
      },
      {
        type: "paragraph",
        text: "위 쿼리는 '학생' 테이블에서 이름이 '김철수'인 행만 조회합니다.",
      },
      {
        type: "subtitle",
        text: "비교 연산자",
      },
      {
        type: "list",
        items: [
          "= : 같음",
          "!= 또는 <> : 같지 않음",
          "> : 큼",
          "< : 작음",
          ">= : 크거나 같음",
          "<= : 작거나 같음",
        ],
      },
      {
        type: "subtitle",
        text: "논리 연산자",
      },
      {
        type: "list",
        items: [
          "AND: 여러 조건이 모두 참일 때",
          "OR: 하나라도 참이면 참",
          "NOT: 조건의 부정을 의미",
        ],
      },
      {
        type: "code",
        language: "sql",
        text: "SELECT * FROM 학생 WHERE 학과 = '컴퓨터공학과' AND 학년 = 3;",
      },
      {
        type: "paragraph",
        text: "위 쿼리는 '컴퓨터공학과'이고, '3학년'인 학생만 조회합니다.",
      },
      {
        type: "subtitle",
        text: "특수 조건 연산자",
      },
      {
        type: "table",
        headers: ["연산자", "설명", "예시"],
        rows: [
          [
            "BETWEEN A AND B",
            "A 이상 B 이하 범위 조건",
            "나이 BETWEEN 20 AND 29",
          ],
          [
            "IN (A, B, C)",
            "여러 값 중 하나라도 일치",
            "학과 IN ('컴공', '수학')",
          ],
          ["LIKE", "패턴 비교 (%, _ 사용)", "이름 LIKE '김%'"],
          ["IS NULL", "NULL 값인지 확인", "전화번호 IS NULL"],
        ],
        caption: "자주 쓰이는 WHERE 절 연산자들",
      },
      {
        type: "subtitle",
        text: "LIKE 연산자 예시",
      },
      {
        type: "list",
        items: [
          `"김%" → '김'으로 시작하는 값`,
          `"__희" → 두 글자이고 마지막 글자가 '희'인 값`,
          `"%철수%" → '철수'를 포함하는 값`,
        ],
      },
      {
        type: "code",
        language: "sql",
        text: "SELECT * FROM 학생 WHERE 이름 LIKE '%민%';",
      },
      {
        type: "paragraph",
        text: "이 쿼리는 이름에 '민'이 포함된 학생을 모두 조회합니다.",
      },
      {
        type: "subtitle",
        text: "주의사항",
      },
      {
        type: "list",
        items: [
          "문자열은 따옴표('')로 감싸야 합니다.",
          "NULL 값은 = 또는 != 연산자로 비교하지 않고 IS NULL 또는 IS NOT NULL을 사용해야 합니다.",
          "조건이 복잡할 경우 괄호를 사용해서 연산자 우선순위를 명확히 해야 합니다.",
        ],
      },
      {
        type: "code",
        language: "sql",
        text: "SELECT * FROM 학생 WHERE (학과 = '컴퓨터공학과' OR 학과 = '수학과') AND 학년 = 2;",
      },
      {
        type: "paragraph",
        text: "이 쿼리는 컴퓨터공학과 또는 수학과에 속한 2학년 학생만 조회합니다.",
      },
      {
        type: "subtitle",
        text: "요약",
      },
      {
        type: "paragraph",
        text: "WHERE 절은 SQL 쿼리에서 데이터를 필터링하는 매우 중요한 도구입니다. 다양한 조건과 연산자를 조합해서 원하는 데이터를 정교하게 조회할 수 있습니다.",
      },
    ],
  },

  "GROUP BY, HAVING 절": {
    title: "GROUP BY / HAVING 절",
    content: [
      {
        type: "paragraph",
        text: "`GROUP BY` 절은 SELECT 문에서 집계 함수(예: COUNT, SUM, AVG 등)와 함께 사용되어 데이터를 그룹 단위로 묶는 데 사용됩니다. `HAVING` 절은 그룹화된 결과에 조건을 걸 때 사용하며, `WHERE` 절과는 달리 집계 함수 결과에 조건을 걸 수 있습니다.",
      },
      {
        type: "subtitle",
        text: "직원 테이블 예시",
      },
      {
        type: "table",
        headers: ["사원ID", "이름", "부서", "급여"],
        rows: [
          [1, "김철수", "영업", 4000],
          [2, "이영희", "영업", 4500],
          [3, "박민수", "개발", 5000],
          [4, "최수진", "개발", 5200],
          [5, "정다은", "개발", 4800],
          [6, "한지훈", "마케팅", 3900],
          [7, "오세훈", "마케팅", 4100],
          [8, "유지은", "영업", 4300],
          [9, "강민지", "개발", 5100],
          [10, "서지환", "개발", 5300],
        ],
        caption: "직원 테이블 데이터 예시",
      },
      {
        type: "subtitle",
        text: "GROUP BY 절 사용 예시",
      },
      {
        type: "code",
        text: "SELECT 부서, COUNT(*) AS 인원수\nFROM 직원\nGROUP BY 부서;",
      },
      {
        type: "table",
        headers: ["부서", "인원수"],
        rows: [
          ["영업", 3],
          ["개발", 5],
          ["마케팅", 2],
        ],
        caption: "부서별 인원수",
      },
      {
        type: "subtitle",
        text: "HAVING 절 사용 예시",
      },
      {
        type: "code",
        text: "SELECT 부서, COUNT(*) AS 인원수\nFROM 직원\nGROUP BY 부서\nHAVING COUNT(*) >= 3;",
      },
      {
        type: "table",
        headers: ["부서", "인원수"],
        rows: [
          ["영업", 3],
          ["개발", 5],
        ],
        caption: "인원수가 3명 이상인 부서",
      },
      {
        type: "subtitle",
        text: "GROUP BY와 HAVING 절의 차이점",
      },
      {
        type: "table",
        headers: ["구분", "GROUP BY", "HAVING"],
        rows: [
          ["목적", "데이터를 그룹으로 묶기", "그룹화된 결과에 조건을 걸기"],
          [
            "사용 위치",
            "`GROUP BY`는 `FROM` 다음에 위치",
            "`HAVING`은 `GROUP BY` 다음에 위치",
          ],
          ["조건 대상", "그룹화 기준 컬럼", "집계 함수의 결과값"],
          ["예시 조건", "`부서`", "`COUNT(*) >= 3`"],
        ],
        caption: "GROUP BY와 HAVING 절의 차이점",
      },
      {
        type: "subtitle",
        text: "주의사항",
      },
      {
        type: "list",
        items: [
          "`SELECT` 절에 나오는 컬럼은 `GROUP BY` 절에 포함되거나, 집계 함수여야 함.",
          "`HAVING` 절은 `GROUP BY` 없이도 집계 함수 조건에 사용할 수 있음.",
          "`WHERE` → `GROUP BY` → `HAVING` → `SELECT` → `ORDER BY` 순으로 실행됨.",
        ],
      },
    ],
  },
  "ORDER BY 절": {
    title: "ORDER BY 절",
    content: [
      {
        type: "paragraph",
        text: "ORDER BY 절은 SQL에서 조회된 결과를 특정 컬럼을 기준으로 정렬할 때 사용하는 구문입니다. 기본값은 오름차순(ASC)이며, 내림차순(DESC)도 지정할 수 있습니다.",
      },
      {
        type: "subtitle",
        text: "학생 테이블 예시 데이터",
      },
      {
        type: "table",
        headers: ["학번", "이름", "학과코드", "학년"],
        rows: [
          [101, "김철수", "CS", 2],
          [102, "이영희", "CS", 3],
          [103, "박민수", "EE", 1],
          [104, "최수진", "CS", 2],
          [105, "정다은", "ME", 4],
          [106, "한지훈", "EE", 2],
          [107, "오세훈", "ME", 1],
        ],
        caption: "학생 테이블 예시 데이터",
      },
      {
        type: "subtitle",
        text: "기본 ORDER BY 절 사용 예시",
      },
      {
        type: "code",
        text: "SELECT 이름, 학년 FROM 학생 ORDER BY 학년 ASC;",
      },
      {
        type: "table",
        headers: ["이름", "학년"],
        rows: [
          ["박민수", 1],
          ["오세훈", 1],
          ["김철수", 2],
          ["최수진", 2],
          ["한지훈", 2],
          ["이영희", 3],
          ["정다은", 4],
        ],
        caption: "학년 오름차순 정렬 결과",
      },
      {
        type: "subtitle",
        text: "ORDER BY 절 기본 구조",
      },
      {
        type: "code",
        text: "SELECT 컬럼명, ... FROM 테이블명 [WHERE 조건식] [GROUP BY 컬럼명] [HAVING 조건식] ORDER BY 컬럼명 [ASC|DESC], ...;",
      },
      {
        type: "subtitle",
        text: "ORDER BY 절의 역할과 특징",
      },
      {
        type: "list",
        items: [
          "조회 결과를 지정한 컬럼을 기준으로 정렬합니다.",
          "여러 컬럼을 지정하여 우선순위별 정렬이 가능합니다.",
          "ASC는 오름차순 정렬, DESC는 내림차순 정렬을 의미합니다.",
          "ORDER BY 절은 SQL 문에서 가장 마지막에 위치합니다.",
        ],
      },
      {
        type: "subtitle",
        text: "SELECT 문의 주요 절 중 ORDER BY 위치",
      },
      {
        type: "list",
        items: [
          "FROM: 데이터 원본 지정",
          "WHERE: 행 필터링 (다음 컨텐츠에서 다룸)",
          "GROUP BY: 그룹화 (다음 컨텐츠에서 다룸)",
          "HAVING: 그룹 조건 필터링 (다음 컨텐츠에서 다룸)",
          "SELECT: 조회 컬럼 지정",
          "ORDER BY: 결과 정렬 (마지막 단계)",
        ],
      },
      {
        type: "subtitle",
        text: "ORDER BY 절 작성 팁",
      },
      {
        type: "list",
        items: [
          "정렬 기준 컬럼은 SELECT 절에 포함되어야 합니다.",
          "별칭(AS)도 ORDER BY 절에서 사용할 수 있습니다.",
          "여러 컬럼을 지정할 때는 쉼표(,)로 구분합니다.",
          "복잡한 정렬 기준은 쿼리 가독성을 위해 주석 활용을 권장합니다.",
        ],
      },
      {
        type: "paragraph",
        text: "ORDER BY 절을 이해하고 적절히 활용하면 원하는 순서대로 데이터를 조회할 수 있어, 보고서 작성이나 데이터 분석에 매우 유용합니다.",
      },
    ],
  },
  조인: {
    title: "조인 (JOIN)",
    content: [
      {
        type: "paragraph",
        text: "조인은 두 개 이상의 테이블을 연결하여 하나의 결과 집합으로 데이터를 조회할 때 사용하는 SQL 구문입니다. 관계형 데이터베이스에서 매우 중요한 개념으로, 관련된 데이터를 함께 볼 수 있도록 해줍니다.",
      },
      {
        type: "subtitle",
        text: "예시 테이블: 학생(Student)",
      },
      {
        type: "table",
        headers: ["학번", "이름", "학과코드"],
        rows: [
          [101, "김철수", "CS"],
          [102, "이영희", "CS"],
          [103, "박민수", "EE"],
          [104, "최수진", "ME"],
        ],
        caption: "학생(Student) 테이블",
      },
      {
        type: "subtitle",
        text: "예시 테이블: 학과(Department)",
      },
      {
        type: "table",
        headers: ["학과코드", "학과명", "학과장"],
        rows: [
          ["CS", "컴퓨터공학과", "홍길동"],
          ["EE", "전기공학과", "김유신"],
          ["ME", "기계공학과", "이순신"],
        ],
        caption: "학과(Department) 테이블",
      },
      {
        type: "subtitle",
        text: "조인 쿼리 예시 (내부 조인 INNER JOIN)",
      },
      {
        type: "code",
        text: "SELECT S.학번, S.이름, D.학과명, D.학과장\nFROM 학생 S\nINNER JOIN 학과 D ON S.학과코드 = D.학과코드;",
      },
      {
        type: "table",
        headers: ["학번", "이름", "학과명", "학과장"],
        rows: [
          [101, "김철수", "컴퓨터공학과", "홍길동"],
          [102, "이영희", "컴퓨터공학과", "홍길동"],
          [103, "박민수", "전기공학과", "김유신"],
          [104, "최수진", "기계공학과", "이순신"],
        ],
        caption: "조인 결과: 학생과 학과 정보를 연결",
      },
      {
        type: "subtitle",
        text: "조인의 기본 구조",
      },
      {
        type: "code",
        text: "SELECT 컬럼명, ...\nFROM 테이블1\nJOIN 종류 테이블2 ON 조건;",
      },
      {
        type: "paragraph",
        text: "조인은 FROM 절 다음에 위치하며, JOIN 뒤에 조인 종류(INNER, LEFT, RIGHT, FULL 등)를 지정할 수 있습니다. ON 절에서는 두 테이블을 연결하는 조건을 명시합니다.",
      },
      {
        type: "subtitle",
        text: "조인 종류와 역할 (다음 컨텐츠에서 자세히 다룸)",
      },
      {
        type: "list",
        items: [
          "INNER JOIN: 양쪽 테이블에 모두 일치하는 데이터만 출력",
          "LEFT JOIN: 왼쪽 테이블의 모든 데이터를 출력하며, 일치하지 않으면 NULL로 표시",
          "RIGHT JOIN: 오른쪽 테이블의 모든 데이터를 출력하며, 일치하지 않으면 NULL로 표시",
          "FULL OUTER JOIN: 양쪽 테이블 모두의 데이터를 모두 출력",
        ],
      },
      {
        type: "paragraph",
        text: "조인은 복잡한 데이터 관계를 쉽게 표현하고, 여러 테이블의 데이터를 통합하여 조회할 때 필수적인 기능입니다.",
      },
    ],
  },
  "표준 조인": {
    title: "표준 조인 (Standard JOIN)",
    content: [
      {
        type: "paragraph",
        text: "표준 조인은 SQL에서 가장 많이 사용되는 조인 방식으로, 두 개 이상의 테이블을 특정 조건으로 연결하여 데이터를 조회합니다.",
      },
      {
        type: "subtitle",
        text: "조인 종류별 특징 및 예시",
      },
      {
        type: "table",
        headers: ["조인 종류", "설명"],
        rows: [
          ["INNER JOIN", "양쪽 테이블에 모두 존재하는 데이터만 조회"],
          [
            "LEFT OUTER JOIN",
            "왼쪽 테이블의 모든 데이터와 일치하는 오른쪽 테이블 데이터를 조회, 일치하지 않으면 NULL",
          ],
          [
            "RIGHT OUTER JOIN",
            "오른쪽 테이블의 모든 데이터와 일치하는 왼쪽 테이블 데이터를 조회, 일치하지 않으면 NULL",
          ],
          [
            "FULL OUTER JOIN",
            "양쪽 테이블의 모든 데이터를 조회, 일치하지 않는 부분은 NULL",
          ],
        ],
        caption: "표준 조인 종류와 특징",
      },
      {
        type: "subtitle",
        text: "예시 테이블: 학생(Student)",
      },
      {
        type: "table",
        headers: ["학번", "이름", "학과코드"],
        rows: [
          [101, "김철수", "CS"],
          [102, "이영희", "CS"],
          [103, "박민수", "EE"],
          [104, "최수진", "ME"],
          [105, "최민호", null],
        ],
        caption: "학생(Student) 테이블",
      },
      {
        type: "subtitle",
        text: "예시 테이블: 학과(Department)",
      },
      {
        type: "table",
        headers: ["학과코드", "학과명"],
        rows: [
          ["CS", "컴퓨터공학과"],
          ["EE", "전기공학과"],
          ["ME", "기계공학과"],
          ["CE", "토목공학과"],
        ],
        caption: "학과(Department) 테이블",
      },
      {
        type: "subtitle",
        text: "1. INNER JOIN 예시",
      },
      {
        type: "code",
        text: "SELECT S.학번, S.이름, D.학과명\nFROM 학생 S\nINNER JOIN 학과 D ON S.학과코드 = D.학과코드;",
      },
      {
        type: "table",
        headers: ["학번", "이름", "학과명"],
        rows: [
          [101, "김철수", "컴퓨터공학과"],
          [102, "이영희", "컴퓨터공학과"],
          [103, "박민수", "전기공학과"],
          [104, "최수진", "기계공학과"],
        ],
        caption: "INNER JOIN 결과 (일치하는 데이터만)",
      },
      {
        type: "subtitle",
        text: "2. LEFT OUTER JOIN 예시",
      },
      {
        type: "code",
        text: "SELECT S.학번, S.이름, D.학과명\nFROM 학생 S\nLEFT OUTER JOIN 학과 D ON S.학과코드 = D.학과코드;",
      },
      {
        type: "table",
        headers: ["학번", "이름", "학과명"],
        rows: [
          [101, "김철수", "컴퓨터공학과"],
          [102, "이영희", "컴퓨터공학과"],
          [103, "박민수", "전기공학과"],
          [104, "최수진", "기계공학과"],
          [105, "최민호", null],
        ],
        caption: "LEFT OUTER JOIN 결과 (왼쪽 테이블 기준 모두 출력)",
      },
      {
        type: "subtitle",
        text: "3. RIGHT OUTER JOIN 예시",
      },
      {
        type: "code",
        text: "SELECT S.학번, S.이름, D.학과명\nFROM 학생 S\nRIGHT OUTER JOIN 학과 D ON S.학과코드 = D.학과코드;",
      },
      {
        type: "table",
        headers: ["학번", "이름", "학과명"],
        rows: [
          [101, "김철수", "컴퓨터공학과"],
          [102, "이영희", "컴퓨터공학과"],
          [103, "박민수", "전기공학과"],
          [104, "최수진", "기계공학과"],
          [null, null, "토목공학과"],
        ],
        caption: "RIGHT OUTER JOIN 결과 (오른쪽 테이블 기준 모두 출력)",
      },
      {
        type: "subtitle",
        text: "4. FULL OUTER JOIN 예시",
      },
      {
        type: "code",
        text: "SELECT S.학번, S.이름, D.학과명\nFROM 학생 S\nFULL OUTER JOIN 학과 D ON S.학과코드 = D.학과코드;",
      },
      {
        type: "table",
        headers: ["학번", "이름", "학과명"],
        rows: [
          [101, "김철수", "컴퓨터공학과"],
          [102, "이영희", "컴퓨터공학과"],
          [103, "박민수", "전기공학과"],
          [104, "최수진", "기계공학과"],
          [105, "최민호", null],
          [null, null, "토목공학과"],
        ],
        caption: "FULL OUTER JOIN 결과 (양쪽 테이블 모두 포함)",
      },
      {
        type: "paragraph",
        text: "표준 조인은 테이블 간 데이터 관계를 명확히 하여 필요한 데이터를 효율적으로 조회할 수 있게 도와줍니다.",
      },
    ],
  },
  "서브 쿼리": {
    title: "서브 쿼리 (Subquery)",
    content: [
      {
        type: "paragraph",
        text: "서브 쿼리는 하나의 SQL 문장 안에 포함된 또 다른 SELECT 문으로, 내부 쿼리가 먼저 실행되어 외부 쿼리에 결과를 제공합니다.",
      },
      {
        type: "subtitle",
        text: "서브 쿼리의 사용 위치",
      },
      {
        type: "list",
        items: [
          "SELECT 절 안에서 컬럼 값을 계산할 때",
          "FROM 절 안에서 테이블처럼 사용될 때",
          "WHERE 절이나 HAVING 절에서 조건으로 사용될 때",
        ],
      },
      {
        type: "subtitle",
        text: "예시 테이블: 학생(Student)",
      },
      {
        type: "table",
        headers: ["학번", "이름", "학과코드", "성적"],
        rows: [
          [101, "김철수", "CS", 85],
          [102, "이영희", "CS", 92],
          [103, "박민수", "EE", 78],
          [104, "최수진", "ME", 88],
          [105, "최민호", "CS", 95],
        ],
        caption: "학생(Student) 테이블",
      },
      {
        type: "subtitle",
        text: "1. WHERE 절에서 서브 쿼리 사용 예시",
      },
      {
        type: "code",
        text: "SELECT 이름, 성적\nFROM 학생\nWHERE 성적 > (SELECT AVG(성적) FROM 학생);",
      },
      {
        type: "table",
        headers: ["이름", "성적"],
        rows: [
          ["이영희", 92],
          ["최수진", 88],
          ["최민호", 95],
        ],
        caption: "전체 학생 평균 성적 이상인 학생 조회 결과",
      },
      {
        type: "subtitle",
        text: "2. FROM 절에서 서브 쿼리 사용 예시",
      },
      {
        type: "code",
        text: "SELECT 학과코드, 평균성적\nFROM (SELECT 학과코드, AVG(성적) AS 평균성적 FROM 학생 GROUP BY 학과코드) AS 학과성적;",
      },
      {
        type: "table",
        headers: ["학과코드", "평균성적"],
        rows: [
          ["CS", 90.67],
          ["EE", 78],
          ["ME", 88],
        ],
        caption: "학과별 평균 성적 조회 결과",
      },
      {
        type: "subtitle",
        text: "3. SELECT 절에서 서브 쿼리 사용 예시",
      },
      {
        type: "code",
        text: "SELECT 이름, 학과코드, (SELECT 학과명 FROM 학과 WHERE 학과.학과코드 = 학생.학과코드) AS 학과명\nFROM 학생;",
      },
      {
        type: "table",
        headers: ["이름", "학과코드", "학과명"],
        rows: [
          ["김철수", "CS", "컴퓨터공학과"],
          ["이영희", "CS", "컴퓨터공학과"],
          ["박민수", "EE", "전기공학과"],
          ["최수진", "ME", "기계공학과"],
          ["최민호", "CS", "컴퓨터공학과"],
        ],
        caption: "SELECT 절에서 서브 쿼리로 학과명 조회 결과",
      },
      {
        type: "paragraph",
        text: "서브 쿼리를 활용하면 복잡한 조건이나 계산을 효율적으로 처리할 수 있으며, 쿼리를 모듈화해 가독성을 높이는 데 도움이 됩니다.",
      },
    ],
  },
  "집합 연산자": {
    title: "집합 연산자 (Set Operators)",
    content: [
      {
        type: "paragraph",
        text: "집합 연산자는 두 개 이상의 SELECT 문의 결과 집합을 결합할 때 사용합니다. 결과는 중복 행을 처리하거나 포함 여부에 따라 다릅니다.",
      },
      {
        type: "subtitle",
        text: "주요 집합 연산자 종류",
      },
      {
        type: "table",
        headers: ["연산자", "설명", "중복 처리"],
        rows: [
          ["UNION", "두 결과 집합의 합집합. 중복된 행은 제거됨.", "중복 제거"],
          [
            "UNION ALL",
            "두 결과 집합의 합집합. 중복된 행도 모두 포함.",
            "중복 허용",
          ],
          [
            "INTERSECT",
            "두 결과 집합의 교집합. 양쪽 모두에 존재하는 행만 포함.",
            "중복 제거",
          ],
          [
            "EXCEPT (또는 MINUS)",
            "첫 번째 집합에서 두 번째 집합에 있는 행을 제외한 결과.",
            "중복 제거",
          ],
        ],
        caption: "SQL 집합 연산자 종류와 특징",
      },
      {
        type: "subtitle",
        text: "예시 테이블: A 테이블",
      },
      {
        type: "table",
        headers: ["번호"],
        rows: [[1], [2], [3]],
        caption: "테이블 A",
      },
      {
        type: "subtitle",
        text: "예시 테이블: B 테이블",
      },
      {
        type: "table",
        headers: ["번호"],
        rows: [[2], [3], [4]],
        caption: "테이블 B",
      },
      {
        type: "subtitle",
        text: "1. UNION 예시",
      },
      {
        type: "code",
        text: "SELECT 번호 FROM A\nUNION\nSELECT 번호 FROM B;",
      },
      {
        type: "table",
        headers: ["번호"],
        rows: [[1], [2], [3], [4]],
        caption: "A와 B의 UNION 결과",
      },
      {
        type: "subtitle",
        text: "2. UNION ALL 예시",
      },
      {
        type: "code",
        text: "SELECT 번호 FROM A\nUNION ALL\nSELECT 번호 FROM B;",
      },
      {
        type: "table",
        headers: ["번호"],
        rows: [[1], [2], [2], [3], [3], [4]],
        caption: "A와 B의 UNION ALL 결과",
      },
      {
        type: "subtitle",
        text: "3. INTERSECT 예시",
      },
      {
        type: "code",
        text: "SELECT 번호 FROM A\nINTERSECT\nSELECT 번호 FROM B;",
      },
      {
        type: "table",
        headers: ["번호"],
        rows: [[2], [3]],
        caption: "A와 B의 INTERSECT 결과",
      },
      {
        type: "subtitle",
        text: "4. EXCEPT (또는 MINUS) 예시",
      },
      {
        type: "code",
        text: "SELECT 번호 FROM A\nEXCEPT\nSELECT 번호 FROM B;",
      },
      {
        type: "table",
        headers: ["번호"],
        rows: [[1]],
        caption: "A에서 B를 뺀 결과 (EXCEPT)",
      },
      {
        type: "paragraph",
        text: "집합 연산자는 두 SELECT 문의 컬럼 수와 데이터 타입이 일치해야 하며, 보통 결과 정렬에는 ORDER BY를 마지막에 한번만 사용합니다.",
      },
    ],
  },
  "그룹 함수": {
    title: "그룹 함수 (Aggregate Functions)",
    content: [
      {
        type: "paragraph",
        text: "그룹 함수는 SQL에서 여러 행의 데이터를 집계하여 하나의 결과값을 만들어내는 함수입니다. 이를 통해 데이터베이스 내 대량의 데이터를 요약하거나 통계적인 정보를 추출할 수 있습니다. 대표적인 그룹 함수로는 COUNT, SUM, AVG, MAX, MIN 등이 있으며, 이 함수들은 각각 특정 컬럼의 행 개수, 합계, 평균, 최대값, 최소값을 계산할 때 사용됩니다.",
      },
      {
        type: "paragraph",
        text: "이러한 그룹 함수는 단독으로도 사용할 수 있지만, 주로 GROUP BY 절과 함께 사용하여 특정 그룹별로 집계 결과를 구할 때 매우 유용합니다. 예를 들어 부서별 직원 수, 판매액 합계, 평균 점수 등 다양한 집계 결과를 쉽게 구할 수 있습니다.",
      },
      {
        type: "subtitle",
        text: "주요 그룹 함수 종류와 설명",
      },
      {
        type: "table",
        headers: ["함수명", "설명", "예시"],
        rows: [
          [
            "COUNT()",
            "행의 개수를 세는 함수로, NULL 값을 제외하지 않고 전체 행 수를 계산하거나 특정 컬럼의 값이 존재하는 행 수를 셀 수 있음.",
            "COUNT(*) - 전체 행 수 계산",
          ],
          [
            "SUM()",
            "수치형 컬럼의 값들을 모두 더해 합계를 반환함. NULL 값은 무시됨.",
            "SUM(급여) - 급여 총합 계산",
          ],
          [
            "AVG()",
            "수치형 컬럼의 평균값을 계산함. SUM을 COUNT로 나눈 값과 같지만 NULL은 제외됨.",
            "AVG(점수) - 평균 점수 계산",
          ],
          [
            "MAX()",
            "컬럼 내 가장 큰 값을 반환함. 날짜, 숫자, 문자열 등에서 사용할 수 있음.",
            "MAX(생년월일) - 가장 늦은 생년월일 찾기",
          ],
          [
            "MIN()",
            "컬럼 내 가장 작은 값을 반환함. 날짜, 숫자, 문자열 등에서 사용할 수 있음.",
            "MIN(점수) - 가장 낮은 점수 찾기",
          ],
        ],
        caption: "주요 그룹 함수와 그 역할 및 예시",
      },
      {
        type: "subtitle",
        text: "예시 데이터: 직원 테이블",
      },
      {
        type: "table",
        headers: ["이름", "부서", "급여"],
        rows: [
          ["김철수", "개발", 5000],
          ["이영희", "개발", 5500],
          ["박민수", "영업", 4000],
          ["최지은", "영업", 4200],
          ["홍길동", "기획", 6000],
        ],
        caption: "직원 테이블 예시",
      },
      {
        type: "subtitle",
        text: "COUNT() 함수 사용 예",
      },
      {
        type: "paragraph",
        text: "전체 직원 수를 구하거나 특정 조건에 맞는 직원 수를 셀 때 사용합니다. 전체 행의 개수를 세려면 COUNT(*)를, 특정 컬럼의 값이 존재하는 행만 세려면 COUNT(컬럼명)을 사용합니다.",
      },
      {
        type: "code",
        text: "SELECT COUNT(*) AS 총직원수 FROM 직원;",
      },
      {
        type: "table",
        headers: ["총직원수"],
        rows: [[5]],
        caption: "직원 전체 수 결과",
      },
      {
        type: "subtitle",
        text: "SUM() 함수와 GROUP BY 절 활용 예",
      },
      {
        type: "paragraph",
        text: "부서별로 급여 총합을 계산할 때 주로 사용합니다. SUM() 함수는 그룹화된 각 부서에 대해 급여 합계를 계산하여 요약 정보를 제공합니다.",
      },
      {
        type: "code",
        text: "SELECT 부서, SUM(급여) AS 부서별_급여합계 FROM 직원 GROUP BY 부서;",
      },
      {
        type: "table",
        headers: ["부서", "부서별_급여합계"],
        rows: [
          ["개발", 10500],
          ["영업", 8200],
          ["기획", 6000],
        ],
        caption: "부서별 급여 합계",
      },
      {
        type: "subtitle",
        text: "AVG() 함수와 GROUP BY 절 활용 예",
      },
      {
        type: "paragraph",
        text: "부서별 평균 급여를 구하는 데 사용됩니다. AVG() 함수는 그룹별 급여의 평균값을 계산하여 각 부서의 급여 수준을 비교할 때 유용합니다.",
      },
      {
        type: "code",
        text: "SELECT 부서, AVG(급여) AS 부서별_평균급여 FROM 직원 GROUP BY 부서;",
      },
      {
        type: "table",
        headers: ["부서", "부서별_평균급여"],
        rows: [
          ["개발", 5250],
          ["영업", 4100],
          ["기획", 6000],
        ],
        caption: "부서별 평균 급여",
      },
      {
        type: "paragraph",
        text: "이처럼 그룹 함수는 데이터의 요약과 통계 분석에 필수적이며, 복잡한 대용량 데이터베이스에서도 빠르게 결과를 도출할 수 있도록 돕습니다.",
      },
      {
        type: "paragraph",
        text: "일반적으로 그룹 함수는 GROUP BY 절과 함께 사용되며, SELECT 절에는 그룹화 기준 컬럼과 집계 함수 결과가 함께 포함되어야 합니다. 그렇지 않으면 에러가 발생할 수 있으니 주의해야 합니다.",
      },
    ],
  },
  "윈도우 함수": {
    title: "윈도우 함수 (Window Functions)",
    content: [
      {
        type: "paragraph",
        text: "윈도우 함수는 SQL에서 각 행에 대해 그룹화된 집계 값을 계산하면서도, 원본 행의 개별 데이터도 유지할 수 있도록 하는 강력한 기능입니다. 일반적인 그룹 함수와 달리 결과 집계 시 행들이 그룹으로 묶여 하나의 행으로 축소되지 않고, 각 행에 대해 계산된 집계 결과를 함께 반환합니다.",
      },
      {
        type: "paragraph",
        text: "윈도우 함수는 금융, 통계, 분석 등 다양한 분야에서 순위, 누적합, 이동평균 등 복잡한 계산을 수행할 때 매우 유용합니다. 데이터 집계와 함께 상세한 행 단위 정보도 함께 확인할 수 있어 데이터 분석에 필수적인 기능입니다.",
      },
      {
        type: "subtitle",
        text: "윈도우 함수 기본 문법",
      },
      {
        type: "code",
        text: "함수명() OVER (\n  [PARTITION BY 컬럼명]\n  [ORDER BY 컬럼명]\n  [ROWS/RANGE 프레임 지정]\n);",
      },
      {
        type: "paragraph",
        text: "`OVER` 절은 윈도우 함수에서 매우 중요한 부분으로, 데이터를 어떻게 나누고 정렬할지 정의합니다. `PARTITION BY`는 데이터를 그룹으로 나누는 역할을 하며, `ORDER BY`는 각 그룹 내에서 행의 순서를 지정합니다. 필요에 따라 `ROWS` 또는 `RANGE`를 지정하여 계산 범위를 조절할 수 있습니다.",
      },
      {
        type: "subtitle",
        text: "주요 윈도우 함수 종류",
      },
      {
        type: "table",
        headers: ["함수명", "설명", "예시"],
        rows: [
          [
            "ROW_NUMBER()",
            "파티션 내에서 행마다 고유 순번을 부여합니다.",
            "각 부서별 직원 순번 생성",
          ],
          [
            "RANK()",
            "같은 값이 있을 경우 동일한 순위를 부여하고, 그 다음 순위는 건너뜁니다.",
            "동점자 처리 시 순위 계산",
          ],
          [
            "DENSE_RANK()",
            "RANK()와 달리 순위 건너뛰지 않고 연속 순위를 부여합니다.",
            "연속된 순위 부여",
          ],
          [
            "SUM()/AVG()/MAX()/MIN() 등",
            "윈도우 함수로 사용하여 누적합, 이동평균 등 계산 가능",
            "부서별 누적 급여 합계 계산",
          ],
        ],
        caption: "주요 윈도우 함수와 설명",
      },
      {
        type: "subtitle",
        text: "예시 데이터: 직원 테이블",
      },
      {
        type: "table",
        headers: ["이름", "부서", "급여"],
        rows: [
          ["김철수", "개발", 5000],
          ["이영희", "개발", 5500],
          ["박민수", "영업", 4000],
          ["최지은", "영업", 4200],
          ["홍길동", "기획", 6000],
        ],
        caption: "직원 테이블 예시",
      },
      {
        type: "subtitle",
        text: "ROW_NUMBER() 함수 사용 예",
      },
      {
        type: "paragraph",
        text: "각 부서별 직원에게 순번을 부여할 때 사용합니다. 부서별로 직원들을 순서대로 번호를 매길 수 있습니다.",
      },
      {
        type: "code",
        text: "SELECT 이름, 부서, 급여,\n       ROW_NUMBER() OVER (PARTITION BY 부서 ORDER BY 급여 DESC) AS 부서내_순번\nFROM 직원;",
      },
      {
        type: "table",
        headers: ["이름", "부서", "급여", "부서내_순번"],
        rows: [
          ["이영희", "개발", 5500, 1],
          ["김철수", "개발", 5000, 2],
          ["최지은", "영업", 4200, 1],
          ["박민수", "영업", 4000, 2],
          ["홍길동", "기획", 6000, 1],
        ],
        caption: "부서별 급여 내림차순으로 순번 부여 결과",
      },
      {
        type: "subtitle",
        text: "누적 합계 예시 (SUM() 윈도우 함수)",
      },
      {
        type: "paragraph",
        text: "부서별로 급여를 오름차순으로 정렬한 후 누적 합계를 계산할 때 사용합니다. 이는 해당 행까지의 급여 합계를 구하는 것입니다.",
      },
      {
        type: "code",
        text: "SELECT 이름, 부서, 급여,\n       SUM(급여) OVER (PARTITION BY 부서 ORDER BY 급여 ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS 누적_급여\nFROM 직원;",
      },
      {
        type: "table",
        headers: ["이름", "부서", "급여", "누적_급여"],
        rows: [
          ["김철수", "개발", 5000, 5000],
          ["이영희", "개발", 5500, 10500],
          ["박민수", "영업", 4000, 4000],
          ["최지은", "영업", 4200, 8200],
          ["홍길동", "기획", 6000, 6000],
        ],
        caption: "부서별 급여 누적 합계 결과",
      },
      {
        type: "paragraph",
        text: "윈도우 함수는 그룹 함수와 달리 데이터를 집계하면서도 원본 데이터를 그대로 유지해 분석과 보고서 작성에 매우 유용합니다. 복잡한 분석 쿼리를 작성할 때 꼭 알아두어야 할 SQL의 고급 기능입니다.",
      },
    ],
  },
  "TOP N 쿼리": {
    title: "TOP N 쿼리",
    content: [
      {
        type: "paragraph",
        text: "TOP N 쿼리는 데이터베이스에서 가장 많이 사용되는 쿼리 중 하나로, 특정 조건에 맞는 데이터 중 상위 N개만을 조회할 때 사용됩니다. 예를 들어, 매출 상위 5개 상품, 급여 상위 10명의 직원, 최근 가입자 상위 3명 등을 조회할 때 매우 유용합니다. 이 쿼리는 대량의 데이터 중 필요한 일부만 빠르게 추출할 수 있어 성능 향상에도 기여합니다.",
      },
      {
        type: "paragraph",
        text: "각 데이터베이스 시스템에서는 TOP N을 구현하는 방식이 조금씩 다릅니다. 공통적으로는 결과를 정렬한 후, 그 중에서 일정 개수만 추출하는 방식입니다. 정렬이 반드시 필요한 이유는, 단순히 첫 N개의 행을 추출하면 원하는 의미의 '상위 N'이 보장되지 않기 때문입니다.",
      },
      {
        type: "subtitle",
        text: "주요 데이터베이스별 TOP N 쿼리 문법 차이",
      },
      {
        type: "table",
        headers: ["DBMS", "문법 예시", "설명"],
        rows: [
          [
            "MySQL, PostgreSQL, SQLite",
            "SELECT * FROM 테이블명 ORDER BY 컬럼명 DESC LIMIT N;",
            "LIMIT 키워드를 사용해 상위 N개의 결과를 제한",
          ],
          [
            "Oracle (12c 이상)",
            "SELECT * FROM 테이블명 ORDER BY 컬럼명 DESC FETCH FIRST N ROWS ONLY;",
            "FETCH FIRST 구문으로 결과 제한 가능",
          ],
          [
            "Oracle (12c 이전)",
            "SELECT * FROM (SELECT * FROM 테이블명 ORDER BY 컬럼명 DESC) WHERE ROWNUM <= N;",
            "서브쿼리와 ROWNUM을 조합하여 상위 N개 결과 추출",
          ],
          [
            "SQL Server",
            "SELECT TOP N * FROM 테이블명 ORDER BY 컬럼명 DESC;",
            "TOP 키워드를 사용해 상위 N개 행을 제한",
          ],
        ],
        caption: "각 DBMS별 TOP N 쿼리 문법 비교",
      },
      {
        type: "subtitle",
        text: "TOP N 쿼리의 동작 원리",
      },
      {
        type: "paragraph",
        text: "TOP N 쿼리는 일반적으로 데이터 전체를 정렬한 후, 그 결과에서 상위 N개만 추출합니다. 따라서 정렬 컬럼의 선택이 매우 중요하며, 원하는 기준으로 정확히 정렬하지 않으면 잘못된 결과를 얻을 수 있습니다. 또한, 인덱스가 적절히 구축되어 있지 않으면 정렬과 추출 과정에서 성능 저하가 발생할 수 있으므로 주의해야 합니다.",
      },
      {
        type: "subtitle",
        text: "예시 테이블: 직원",
      },
      {
        type: "table",
        headers: ["이름", "부서", "급여"],
        rows: [
          ["김철수", "개발", 5000],
          ["이영희", "개발", 5500],
          ["박민수", "영업", 4000],
          ["최지은", "영업", 4200],
          ["홍길동", "기획", 6000],
          ["강민준", "기획", 5800],
          ["이수진", "개발", 5300],
        ],
        caption: "직원 테이블 예시",
      },
      {
        type: "subtitle",
        text: "급여 상위 3명 조회 쿼리 (MySQL, PostgreSQL 등)",
      },
      {
        type: "code",
        text: "SELECT 이름, 부서, 급여\nFROM 직원\nORDER BY 급여 DESC\nLIMIT 3;",
      },
      {
        type: "table",
        headers: ["이름", "부서", "급여"],
        rows: [
          ["홍길동", "기획", 6000],
          ["강민준", "기획", 5800],
          ["이영희", "개발", 5500],
        ],
        caption: "급여 상위 3명 결과",
      },
      {
        type: "subtitle",
        text: "SQL Server에서 TOP N 쿼리 예",
      },
      {
        type: "code",
        text: "SELECT TOP 3 이름, 부서, 급여\nFROM 직원\nORDER BY 급여 DESC;",
      },
      {
        type: "paragraph",
        text: "SQL Server는 TOP 키워드를 사용해 제한 개수를 지정하며, ORDER BY 절과 함께 사용하여 원하는 순서대로 결과를 정렬합니다.",
      },
      {
        type: "subtitle",
        text: "TOP N 쿼리 작성 시 주의사항",
      },
      {
        type: "list",
        items: [
          "ORDER BY 절 없이 LIMIT, TOP을 사용하면 어떤 데이터가 추출될지 예측할 수 없음",
          "대량의 데이터에서 정렬 작업은 비용이 크므로 인덱스를 활용하여 성능 최적화 필요",
          "동일한 값이 여러 개일 때 순서가 모호할 수 있으므로, 추가 정렬 기준을 명확히 지정하는 것이 좋음",
          "Oracle 12c 이전 버전에서는 ROWNUM과 서브쿼리를 조합해 TOP N 구현 필요",
        ],
      },
      {
        type: "paragraph",
        text: "TOP N 쿼리는 실무에서 매우 자주 사용되므로, 각 DBMS의 문법과 동작 방식을 명확히 이해하는 것이 중요합니다. 또한, 쿼리 성능 향상을 위해 적절한 인덱스 설계와 실행 계획 분석도 병행해야 합니다.",
      },
    ],
  },
  "계층형 질의와 셀프 조인": {
    title: "계층형 질의와 셀프 조인",
    content: [
      {
        type: "paragraph",
        text: "계층형 질의는 데이터가 부모-자식 구조로 연결되어 있을 때, 그 관계를 탐색하고 조회하는 방법입니다. 예를 들어 회사 조직도, 제품 분류 체계, 댓글과 답글 구조 등이 계층형 데이터에 해당합니다. 이러한 구조를 SQL에서 효율적으로 다루기 위해 계층형 질의와 셀프 조인 기법이 필요합니다.",
      },
      {
        type: "paragraph",
        text: "셀프 조인은 같은 테이블을 두 번 이상 불러와 서로 다른 별칭(alias)을 붙여 조인하는 기법입니다. 특히 한 테이블 내에서 부모-자식 관계를 나타낼 때 주로 사용하며, 이를 통해 계층형 데이터를 연결하고 탐색할 수 있습니다.",
      },
      {
        type: "subtitle",
        text: "계층형 데이터의 특징과 구조",
      },
      {
        type: "paragraph",
        text: "계층형 데이터는 트리 구조와 같이 하나의 부모 노드가 여러 자식 노드를 가지며, 각 노드가 다시 부모 노드가 될 수 있는 형태입니다. 예를 들어 직원 테이블에서 각 직원은 자신의 상사를 가리키는 상사ID 컬럼을 가질 수 있습니다. 이 때, 상사-부하 관계가 부모-자식 관계가 됩니다.",
      },
      {
        type: "subtitle",
        text: "셀프 조인 기본 개념과 문법",
      },
      {
        type: "paragraph",
        text: "셀프 조인은 동일한 테이블을 두 개 이상 불러와 별칭(alias)을 붙이고, 각 별칭이 다른 역할을 하도록 합니다. 예를 들어 한 별칭은 직원 정보를, 다른 별칭은 그 직원의 상사 정보를 담도록 할 수 있습니다.",
      },
      {
        type: "subtitle",
        text: "예시 테이블: 직원 (EMPLOYEE)",
      },
      {
        type: "table",
        headers: ["사원ID", "이름", "상사ID"],
        rows: [
          [1, "홍길동", null],
          [2, "김철수", 1],
          [3, "이영희", 1],
          [4, "박민수", 2],
          [5, "최지은", 2],
        ],
        caption: "직원 테이블: 각 직원과 그 상사를 나타냄",
      },
      {
        type: "subtitle",
        text: "셀프 조인 예시: 직원과 상사 이름 함께 조회",
      },
      {
        type: "code",
        text: "SELECT E.이름 AS 직원, M.이름 AS 상사\nFROM EMPLOYEE E\nLEFT JOIN EMPLOYEE M ON E.상사ID = M.사원ID;",
      },
      {
        type: "table",
        headers: ["직원", "상사"],
        rows: [
          ["홍길동", null],
          ["김철수", "홍길동"],
          ["이영희", "홍길동"],
          ["박민수", "김철수"],
          ["최지은", "김철수"],
        ],
        caption: "셀프 조인으로 직원과 상사 관계를 함께 조회한 결과",
      },
      {
        type: "paragraph",
        text: "위 쿼리는 EMPLOYEE 테이블을 두 번 불러와 각각 E와 M이라는 별칭을 붙이고, E의 상사ID와 M의 사원ID가 같은 행을 연결하여 직원과 상사 이름을 동시에 보여줍니다. LEFT JOIN을 사용하여 상사가 없는 최고관리자도 결과에 포함합니다.",
      },
      {
        type: "subtitle",
        text: "계층형 질의의 심화: 재귀 쿼리",
      },
      {
        type: "paragraph",
        text: "기본적인 셀프 조인은 한 단계의 부모-자식 관계를 조회할 때 유용하지만, 여러 단계의 계층을 모두 탐색하려면 재귀 쿼리를 사용해야 합니다. 예를 들어, SQL Server의 CTE(Common Table Expression) 또는 Oracle의 CONNECT BY 구문을 통해 재귀적으로 데이터를 조회할 수 있습니다.",
      },
      {
        type: "paragraph",
        text: "재귀 쿼리는 시작점(root)을 정하고, 그 부모 또는 자식 노드를 반복해서 찾는 방식으로 계층 전체를 탐색합니다. 이를 통해 조직도의 모든 하위 직원 또는 카테고리의 모든 하위 항목을 쉽게 조회할 수 있습니다.",
      },
      {
        type: "subtitle",
        text: "SQLD 시험과 실무에서의 중요성",
      },
      {
        type: "paragraph",
        text: "계층형 질의와 셀프 조인은 SQLD 자격증 시험의 중요한 출제 범위입니다. 기본 개념부터 시작해 재귀 쿼리 작성법까지 이해하는 것이 필요합니다. 실무에서도 조직도 관리, 제품 카테고리 관리, 댓글 시스템 구현 등 다양한 분야에서 계층형 데이터 처리가 필수적이므로 깊게 익혀두면 좋습니다.",
      },
      {
        type: "subtitle",
        text: "학습 팁 및 주의사항",
      },
      {
        type: "list",
        items: [
          "테이블 내 자기 참조 관계 이해하기",
          "셀프 조인 시 별칭 사용에 익숙해지기",
          "기본 셀프 조인으로 1단계 부모-자식 관계 익히기",
          "재귀 쿼리(CTE, CONNECT BY) 문법은 단계별로 학습",
          "실제 조직도, 카테고리 데이터를 예시로 연습하기",
          "쿼리 결과가 많아질 수 있으니 테스트 데이터로 충분히 연습하기",
        ],
      },
      {
        type: "paragraph",
        text: "SQLD 준비하는 고등학생 여러분, 계층형 질의와 셀프 조인은 어려워 보일 수 있지만, 이해하고 연습하면 데이터베이스를 더 깊게 다룰 수 있게 됩니다. 천천히 차근차근 개념을 익히고, 여러 실습 문제로 실력을 쌓아가세요!",
      },
    ],
  },
  "PIVOT과 UNPIVOT 절": {
    title: "PIVOT 절과 UNPIVOT 절",
    content: [
      {
        type: "paragraph",
        text: "PIVOT과 UNPIVOT 절은 SQL에서 데이터를 행과 열을 변환하는 데 사용되는 중요한 기능입니다. 이 기능들은 특히 보고서나 데이터 분석에서 데이터를 더 쉽게 이해하고 정리할 때 유용합니다. SQLD 자격증을 준비하는 고등학생 여러분도 꼭 알아야 할 개념입니다.",
      },
      {
        type: "subtitle",
        text: "PIVOT 절이란?",
      },
      {
        type: "paragraph",
        text: "PIVOT 절은 여러 행에 나누어져 있는 데이터를 하나의 행으로 합쳐서 열(column) 형태로 바꾸는 기능입니다. 예를 들어, 월별 판매량 데이터를 ‘월’별로 행에 나열하는 대신, ‘월’별 컬럼을 만들어 한 행에 데이터를 요약할 때 사용합니다.",
      },
      {
        type: "subtitle",
        text: "예시 테이블: 월별 판매 데이터 (SALES)",
      },
      {
        type: "table",
        headers: ["제품명", "월", "판매량"],
        rows: [
          ["사과", "1월", 100],
          ["사과", "2월", 150],
          ["바나나", "1월", 200],
          ["바나나", "2월", 180],
        ],
        caption: "원본 SALES 테이블: 제품별, 월별 판매량",
      },
      {
        type: "subtitle",
        text: "PIVOT 쿼리 예시",
      },
      {
        type: "code",
        text: "SELECT *\nFROM (\n  SELECT 제품명, 월, 판매량\n  FROM SALES\n) AS SourceTable\nPIVOT (\n  SUM(판매량)\n  FOR 월 IN ([1월], [2월])\n) AS PivotTable;",
      },
      {
        type: "table",
        headers: ["제품명", "1월", "2월"],
        rows: [
          ["사과", 100, 150],
          ["바나나", 200, 180],
        ],
        caption: "PIVOT 결과: 월별 판매량이 각각의 열로 변환됨",
      },
      {
        type: "paragraph",
        text: "위 쿼리는 SALES 테이블에서 제품별로 월별 판매량을 각각의 컬럼(1월, 2월)으로 펼쳐서 보여줍니다. SUM(판매량) 집계 함수를 사용하여 같은 제품의 월별 판매량을 합산합니다.",
      },
      {
        type: "subtitle",
        text: "UNPIVOT 절이란?",
      },
      {
        type: "paragraph",
        text: "UNPIVOT 절은 PIVOT과 반대로, 여러 열로 나누어져 있는 데이터를 행(row) 형태로 바꾸는 기능입니다. 즉, 열에 있는 데이터를 다시 행으로 변환해 원래 형태처럼 보이게 합니다.",
      },
      {
        type: "subtitle",
        text: "예시 테이블: 월별 판매량 피벗된 결과",
      },
      {
        type: "table",
        headers: ["제품명", "1월", "2월"],
        rows: [
          ["사과", 100, 150],
          ["바나나", 200, 180],
        ],
        caption: "PIVOT 처리된 판매 데이터",
      },
      {
        type: "subtitle",
        text: "UNPIVOT 쿼리 예시",
      },
      {
        type: "code",
        text: "SELECT 제품명, 월, 판매량\nFROM (\n  SELECT 제품명, [1월], [2월]\n  FROM PivotTable\n) AS PivotedData\nUNPIVOT (\n  판매량 FOR 월 IN ([1월], [2월])\n) AS UnpivotTable;",
      },
      {
        type: "table",
        headers: ["제품명", "월", "판매량"],
        rows: [
          ["사과", "1월", 100],
          ["사과", "2월", 150],
          ["바나나", "1월", 200],
          ["바나나", "2월", 180],
        ],
        caption: "UNPIVOT 결과: 열이 다시 행으로 변환됨",
      },
      {
        type: "paragraph",
        text: "위 쿼리는 PIVOT 처리된 데이터를 다시 원래의 행 형태로 변환합니다. UNPIVOT 절에서는 FOR 뒤에 변환할 열 이름을 지정하며, 각 열이 행의 값으로 바뀝니다.",
      },
      {
        type: "subtitle",
        text: "PIVOT과 UNPIVOT의 활용 팁",
      },
      {
        type: "list",
        items: [
          "보고서에서 열과 행의 형태를 바꿔야 할 때 사용합니다.",
          "PIVOT은 데이터를 요약하거나 열 형태로 보고 싶을 때 적합합니다.",
          "UNPIVOT은 데이터 정규화나 행 형태로 다시 분석하고자 할 때 유용합니다.",
          "복잡한 데이터 변환 시, 먼저 원본 데이터를 잘 이해하는 것이 중요합니다.",
        ],
      },
    ],
  },
  "정규 표현식": {
    title: "정규 표현식 (Regular Expression)",
    content: [
      {
        type: "paragraph",
        text: "정규 표현식은 문자열에서 특정한 패턴을 찾아내거나, 검색, 치환, 검증 등에 사용하는 강력한 도구입니다. SQLD 자격증을 준비하는 고등학생이라면, 정규 표현식을 활용하여 복잡한 문자열 데이터를 효율적으로 다루는 방법을 이해하는 것이 중요합니다.",
      },
      {
        type: "subtitle",
        text: "정규 표현식이란?",
      },
      {
        type: "paragraph",
        text: "정규 표현식은 문자들의 패턴을 표현하는 방식으로, 특정 조건을 만족하는 문자열을 찾기 위해 사용됩니다. 예를 들어, 이메일 형식, 전화번호 형식, 특정 단어 포함 여부 등을 쉽게 검사할 수 있습니다.",
      },
      {
        type: "subtitle",
        text: "정규 표현식 기본 구성요소",
      },
      {
        type: "table",
        headers: ["기호", "의미", "예시"],
        rows: [
          [" . ", "임의의 한 문자", "a.c는 abc, a1c, a-c 모두 매칭"],
          [" * ", "0회 이상 반복", "ab*c는 ac, abc, abbc 모두 매칭"],
          [" + ", "1회 이상 반복", "ab+c는 abc, abbc는 매칭, ac는 매칭 안 됨"],
          [" ? ", "0회 또는 1회", "ab?c는 ac 또는 abc와 매칭"],
          [" [abc] ", "괄호 안 문자 중 하나", "[abc]는 a, b, c 중 하나와 매칭"],
          [
            " [^abc] ",
            "괄호 안 문자를 제외한 문자",
            "[^abc]는 a,b,c를 제외한 문자 매칭",
          ],
          [" ^ ", "문자열 시작", "^abc는 'abc'로 시작하는 문자열"],
          [" $ ", "문자열 끝", "abc$는 'abc'로 끝나는 문자열"],
          [" \\d ", "숫자 (0~9)", "\\d는 숫자 한 자리"],
          [" \\w ", "알파벳, 숫자, 밑줄", "\\w는 문자나 숫자 한 자리"],
          [" \\s ", "공백 문자", "\\s는 공백, 탭, 줄바꿈 등"],
          [" | ", "또는", "abc|def는 'abc' 또는 'def' 매칭"],
        ],
        caption: "정규 표현식 주요 메타 문자",
      },
      {
        type: "subtitle",
        text: "SQL에서 정규 표현식 활용",
      },
      {
        type: "paragraph",
        text: "SQL에서 정규 표현식을 직접 지원하는 함수는 DBMS마다 다르지만, 대표적으로 `REGEXP_LIKE` (Oracle), `RLIKE` (MySQL), `SIMILAR TO` (PostgreSQL) 등이 있습니다. 이를 통해 데이터베이스 내에서 패턴 검색을 할 수 있습니다.",
      },
      {
        type: "subtitle",
        text: "예시 1: 이메일 형식 검사",
      },
      {
        type: "table",
        caption: "사용자 테이블 예시",
        headers: ["사용자ID", "이름", "이메일"],
        rows: [
          ["U01", "김철수", "chulsu.kim@example.com"],
          ["U02", "이영희", "younghee.lee@domain"],
          ["U03", "박민수", "minsu_park@example.co.kr"],
          ["U04", "최지은", "jieun.choi@example.com"],
          ["U05", "한나래", "hannarae@domain.com"],
        ],
      },
      {
        type: "code",
        text: "-- Oracle SQL 예시: 이메일 형식이 올바른 데이터 조회\nSELECT 사용자ID, 이름, 이메일\nFROM 사용자\nWHERE REGEXP_LIKE(이메일, '^[\\w.-]+@[\\w.-]+\\.\\w{2,}$');",
      },
      {
        type: "table",
        caption: "쿼리 결과: 올바른 이메일 형식 데이터",
        headers: ["사용자ID", "이름", "이메일"],
        rows: [
          ["U01", "김철수", "chulsu.kim@example.com"],
          ["U03", "박민수", "minsu_park@example.co.kr"],
          ["U04", "최지은", "jieun.choi@example.com"],
          ["U05", "한나래", "hannarae@domain.com"],
        ],
      },
      {
        type: "subtitle",
        text: "예시 2: 전화번호 형식 검사",
      },
      {
        type: "table",
        caption: "고객 테이블 예시",
        headers: ["고객ID", "이름", "전화번호"],
        rows: [
          ["C001", "박지훈", "010-1234-5678"],
          ["C002", "한수민", "010-9876-5432"],
          ["C003", "이도윤", "02-123-4567"],
          ["C004", "정서연", "010-123-456"],
          ["C005", "오민재", "010-1111-2222"],
        ],
      },
      {
        type: "code",
        text: "-- MySQL 예시: 전화번호가 '010-xxxx-xxxx' 형식인지 검사\nSELECT 고객ID, 이름, 전화번호\nFROM 고객\nWHERE 전화번호 RLIKE '^010-[0-9]{4}-[0-9]{4}$';",
      },
      {
        type: "table",
        caption: "쿼리 결과: 올바른 전화번호 형식 데이터",
        headers: ["고객ID", "이름", "전화번호"],
        rows: [
          ["C001", "박지훈", "010-1234-5678"],
          ["C002", "한수민", "010-9876-5432"],
          ["C005", "오민재", "010-1111-2222"],
        ],
      },
      {
        type: "subtitle",
        text: "정규 표현식 사용 시 주의사항",
      },
      {
        type: "list",
        items: [
          "DBMS마다 정규 표현식 함수와 문법이 조금씩 다를 수 있으니 매뉴얼을 꼭 확인하세요.",
          "복잡한 패턴을 다룰 때는 단계별로 테스트하며 작성하는 것이 좋습니다.",
          "잘못된 정규 표현식은 성능 저하를 일으킬 수 있으니 주의하세요.",
          "정규 표현식은 대소문자를 구분하기 때문에 필요 시 옵션을 설정해야 합니다.",
        ],
      },
    ],
  },
  DML: {
    title: "DML (Data Manipulation Language)",
    content: [
      {
        type: "paragraph",
        text: "DML은 데이터베이스에서 데이터를 실제로 조작하는 데 사용하는 SQL 명령어들을 말합니다. 즉, 데이터를 삽입(INSERT), 수정(UPDATE), 삭제(DELETE), 조회(SELECT)하는 데 필요한 구문들이 모두 포함됩니다. SQLD 자격증을 준비하는 고등학생이라면 DML을 잘 이해하고 활용하는 것이 매우 중요합니다.",
      },
      {
        type: "subtitle",
        text: "DML의 주요 명령어",
      },
      {
        type: "table",
        headers: ["명령어", "역할", "설명"],
        rows: [
          ["INSERT", "데이터 삽입", "테이블에 새로운 행(row)을 추가할 때 사용"],
          ["UPDATE", "데이터 수정", "기존 행의 특정 컬럼 값을 변경할 때 사용"],
          ["DELETE", "데이터 삭제", "조건에 맞는 행을 삭제할 때 사용"],
          [
            "SELECT",
            "데이터 조회",
            "테이블에서 원하는 데이터를 검색할 때 사용",
          ],
        ],
        caption: "DML 주요 명령어와 역할",
      },
      {
        type: "subtitle",
        text: "예시 테이블: 학생(Student)",
      },
      {
        type: "table",
        headers: ["학번", "이름", "학과", "학년"],
        rows: [
          ["2023001", "김민수", "컴퓨터공학", 2],
          ["2023002", "이영희", "전자공학", 1],
          ["2023003", "박철수", "경영학", 3],
        ],
        caption: "초기 학생 테이블 데이터",
      },
      {
        type: "subtitle",
        text: "INSERT - 데이터 삽입",
      },
      {
        type: "paragraph",
        text: "INSERT 명령어를 사용해 학생 테이블에 새로운 학생 정보를 추가할 수 있습니다.",
      },
      {
        type: "code",
        text: "INSERT INTO 학생 (학번, 이름, 학과, 학년) VALUES ('2023004', '최지은', '컴퓨터공학', 1);",
      },
      {
        type: "paragraph",
        text: "이 명령어를 실행하면 다음과 같이 데이터가 추가됩니다.",
      },
      {
        type: "table",
        headers: ["학번", "이름", "학과", "학년"],
        rows: [
          ["2023001", "김민수", "컴퓨터공학", 2],
          ["2023002", "이영희", "전자공학", 1],
          ["2023003", "박철수", "경영학", 3],
          ["2023004", "최지은", "컴퓨터공학", 1],
        ],
        caption: "INSERT 실행 후 학생 테이블",
      },
      {
        type: "subtitle",
        text: "UPDATE - 데이터 수정",
      },
      {
        type: "paragraph",
        text: "UPDATE 명령어를 사용하여 특정 학생의 학년을 변경할 수 있습니다.",
      },
      {
        type: "code",
        text: "UPDATE 학생 SET 학년 = 2 WHERE 학번 = '2023002';",
      },
      {
        type: "paragraph",
        text: "이 명령어를 실행하면 이영희 학생의 학년이 1학년에서 2학년으로 변경됩니다.",
      },
      {
        type: "table",
        headers: ["학번", "이름", "학과", "학년"],
        rows: [
          ["2023001", "김민수", "컴퓨터공학", 2],
          ["2023002", "이영희", "전자공학", 2],
          ["2023003", "박철수", "경영학", 3],
          ["2023004", "최지은", "컴퓨터공학", 1],
        ],
        caption: "UPDATE 실행 후 학생 테이블",
      },
      {
        type: "subtitle",
        text: "DELETE - 데이터 삭제",
      },
      {
        type: "paragraph",
        text: "DELETE 명령어를 사용하여 특정 학생의 데이터를 삭제할 수 있습니다.",
      },
      {
        type: "code",
        text: "DELETE FROM 학생 WHERE 학번 = '2023003';",
      },
      {
        type: "paragraph",
        text: "이 명령어를 실행하면 박철수 학생의 데이터가 삭제됩니다.",
      },
      {
        type: "table",
        headers: ["학번", "이름", "학과", "학년"],
        rows: [
          ["2023001", "김민수", "컴퓨터공학", 2],
          ["2023002", "이영희", "전자공학", 2],
          ["2023004", "최지은", "컴퓨터공학", 1],
        ],
        caption: "DELETE 실행 후 학생 테이블",
      },
      {
        type: "subtitle",
        text: "SELECT - 데이터 조회 (간단히)",
      },
      {
        type: "paragraph",
        text: "SELECT 명령어는 DML에서 데이터를 조회할 때 사용합니다. 상세 내용은 별도 컨텐츠에서 다루지만, DML의 기본 명령어임을 기억하세요.",
      },
      {
        type: "paragraph",
        text: "예를 들어, 학생 테이블에서 모든 학생을 조회하려면 `SELECT * FROM 학생;`를 사용합니다.",
      },
      {
        type: "subtitle",
        text: "DML 작성 시 주의사항",
      },
      {
        type: "list",
        items: [
          "데이터를 변경하는 INSERT, UPDATE, DELETE는 실행 전에 꼭 조건을 확인하세요. 잘못 실행하면 데이터 손실이 발생할 수 있습니다.",
          "UPDATE나 DELETE 시 조건절(WHERE)을 빼먹으면 전체 데이터가 변경/삭제될 수 있으니 주의해야 합니다.",
          "INSERT 시 컬럼과 값의 순서를 정확히 맞춰야 오류가 발생하지 않습니다.",
          "트랜잭션 처리(Commit, Rollback)를 알아두면 실수 시 복구할 수 있어 안전합니다.",
        ],
      },
      {
        type: "paragraph",
        text: "DML은 데이터베이스 조작의 핵심이므로 실습을 통해 여러 명령어를 익히고, 자주 연습하는 것이 SQLD 시험 합격에 큰 도움이 됩니다.",
      },
    ],
  },
  TCL: {
    title: "TCL (Transaction Control Language)",
    content: [
      {
        type: "paragraph",
        text: "TCL은 데이터베이스에서 트랜잭션(transaction)을 제어하는 명령어를 말합니다. 트랜잭션은 하나의 작업 단위로, 여러 개의 SQL 명령어가 하나로 묶여서 실행됩니다. SQLD 자격증을 준비하는 고등학생이라면, 데이터베이스의 안전성과 일관성을 유지하기 위해 TCL 명령어를 잘 이해하는 것이 중요합니다.",
      },
      {
        type: "subtitle",
        text: "트랜잭션이란?",
      },
      {
        type: "paragraph",
        text: "트랜잭션은 여러 작업이 모두 성공해야만 최종적으로 데이터베이스에 반영되는 작업 단위입니다. 만약 도중에 오류가 발생하면 모든 작업을 원래 상태로 되돌릴 수 있어야 합니다. 이를 통해 데이터의 무결성과 일관성을 보장할 수 있습니다.",
      },
      {
        type: "subtitle",
        text: "TCL 주요 명령어",
      },
      {
        type: "table",
        headers: ["명령어", "역할", "설명"],
        rows: [
          ["COMMIT", "트랜잭션 확정", "작업한 내용을 데이터베이스에 영구 저장"],
          [
            "ROLLBACK",
            "트랜잭션 취소",
            "작업한 내용을 모두 취소하고 이전 상태로 되돌림",
          ],
          [
            "SAVEPOINT",
            "중간 저장점 설정",
            "트랜잭션 내에서 특정 지점을 저장하여 그 지점까지 롤백 가능",
          ],
          [
            "SET TRANSACTION",
            "트랜잭션 특성 설정",
            "트랜잭션의 격리 수준 등을 설정",
          ],
        ],
        caption: "TCL 주요 명령어와 역할",
      },
      {
        type: "subtitle",
        text: "예시 테이블: 계좌(Account)",
      },
      {
        type: "table",
        headers: ["계좌번호", "이름", "잔액"],
        rows: [
          ["1001", "김철수", 50000],
          ["1002", "이영희", 30000],
        ],
        caption: "초기 계좌 테이블 데이터",
      },
      {
        type: "subtitle",
        text: "COMMIT - 작업 확정",
      },
      {
        type: "paragraph",
        text: "트랜잭션 내에서 여러 작업을 수행한 뒤, 작업 결과를 데이터베이스에 영구 저장할 때 사용합니다.",
      },
      {
        type: "code",
        text: "-- 김철수 계좌에서 10000원 출금하고 이영희 계좌에 입금\nBEGIN TRANSACTION;\nUPDATE 계좌 SET 잔액 = 잔액 - 10000 WHERE 계좌번호 = '1001';\nUPDATE 계좌 SET 잔액 = 잔액 + 10000 WHERE 계좌번호 = '1002';\nCOMMIT;",
      },
      {
        type: "paragraph",
        text: "COMMIT이 실행되면 두 작업 모두 데이터베이스에 확정되어 잔액이 변경됩니다.",
      },
      {
        type: "table",
        headers: ["계좌번호", "이름", "잔액"],
        rows: [
          ["1001", "김철수", 40000],
          ["1002", "이영희", 40000],
        ],
        caption: "COMMIT 실행 후 계좌 테이블",
      },
      {
        type: "subtitle",
        text: "ROLLBACK - 작업 취소",
      },
      {
        type: "paragraph",
        text: "트랜잭션 내에서 작업 중 오류가 발생하거나 작업을 취소하고 싶을 때 사용합니다.",
      },
      {
        type: "code",
        text: "-- 오류 발생으로 인해 작업 취소\nBEGIN TRANSACTION;\nUPDATE 계좌 SET 잔액 = 잔액 - 10000 WHERE 계좌번호 = '1001';\n-- 오류 발생\nROLLBACK;",
      },
      {
        type: "paragraph",
        text: "ROLLBACK이 실행되면 이전 상태로 돌아가서 잔액 변경이 취소됩니다.",
      },
      {
        type: "table",
        headers: ["계좌번호", "이름", "잔액"],
        rows: [
          ["1001", "김철수", 50000],
          ["1002", "이영희", 40000],
        ],
        caption: "ROLLBACK 실행 후 계좌 테이블",
      },
      {
        type: "subtitle",
        text: "SAVEPOINT - 중간 저장점",
      },
      {
        type: "paragraph",
        text: "트랜잭션 내에서 특정 시점을 저장해두고, 그 시점까지만 롤백할 수 있게 하는 기능입니다.",
      },
      {
        type: "code",
        text: "BEGIN TRANSACTION;\nUPDATE 계좌 SET 잔액 = 잔액 - 10000 WHERE 계좌번호 = '1001';\nSAVEPOINT 중간점;\nUPDATE 계좌 SET 잔액 = 잔액 + 10000 WHERE 계좌번호 = '1002';\n-- 문제가 생기면 중간점까지 롤백\nROLLBACK TO 중간점;\nCOMMIT;",
      },
      {
        type: "paragraph",
        text: "이 경우 두 번째 업데이트는 취소되고, 첫 번째 업데이트만 최종 저장됩니다.",
      },
      {
        type: "table",
        headers: ["계좌번호", "이름", "잔액"],
        rows: [
          ["1001", "김철수", 40000],
          ["1002", "이영희", 30000],
        ],
        caption: "SAVEPOINT와 ROLLBACK TO 실행 후 계좌 테이블",
      },
      {
        type: "subtitle",
        text: "SET TRANSACTION - 트랜잭션 특성 설정",
      },
      {
        type: "paragraph",
        text: "트랜잭션의 격리 수준(isolation level) 등을 설정하여 동시성 제어나 데이터 일관성을 조절할 수 있습니다. SQLD 시험에서는 기본 개념 정도만 이해해도 충분합니다.",
      },
      {
        type: "subtitle",
        text: "TCL 사용 시 주의사항",
      },
      {
        type: "list",
        items: [
          "COMMIT 후에는 롤백할 수 없으므로 작업 내용을 신중히 확인하세요.",
          "ROLLBACK은 트랜잭션 내에서만 유효하며, 트랜잭션이 없으면 영향을 주지 않습니다.",
          "트랜잭션은 데이터의 일관성과 무결성을 지키는 중요한 기능입니다. SQLD 시험에서는 트랜잭션의 기본 개념과 TCL 명령어 역할을 꼭 숙지하세요.",
        ],
      },
      {
        type: "paragraph",
        text: "TCL은 데이터베이스 작업의 안전성을 높이는 핵심 명령어 집합입니다. 실제로 여러 작업을 묶어 처리할 때 반드시 이해하고 활용할 줄 알아야 합니다.",
      },
    ],
  },
  DDL: {
    title: "DDL (Data Definition Language)",
    content: [
      {
        type: "paragraph",
        text: "DDL은 데이터베이스에서 테이블, 인덱스, 뷰 등의 구조를 정의하거나 변경하는 데 사용하는 SQL 명령어입니다. SQLD 자격증을 준비하는 고등학생이라면 데이터베이스 구조를 만드는 방법과 이를 관리하는 기본 명령어를 잘 이해하는 것이 중요합니다.",
      },
      {
        type: "subtitle",
        text: "DDL 주요 명령어",
      },
      {
        type: "table",
        headers: ["명령어", "역할", "설명"],
        rows: [
          [
            "CREATE",
            "객체 생성",
            "테이블, 인덱스, 뷰 등 데이터베이스 객체를 새로 만듦",
          ],
          ["ALTER", "객체 변경", "기존 테이블에 컬럼 추가, 삭제 또는 수정"],
          ["DROP", "객체 삭제", "테이블이나 인덱스 등 객체를 삭제"],
          [
            "TRUNCATE",
            "데이터 삭제",
            "테이블 내 모든 데이터를 빠르게 삭제 (구조는 유지)",
          ],
        ],
        caption: "DDL 주요 명령어와 역할",
      },
      {
        type: "subtitle",
        text: "예시 1: CREATE TABLE",
      },
      {
        type: "paragraph",
        text: "학생 정보를 저장할 테이블을 생성하는 예시입니다.",
      },
      {
        type: "code",
        text: "CREATE TABLE 학생 (\n  학번 INT PRIMARY KEY,\n  이름 VARCHAR(50),\n  학과코드 VARCHAR(10),\n  입학년도 INT\n);",
      },
      {
        type: "subtitle",
        text: "예시 2: ALTER TABLE",
      },
      {
        type: "paragraph",
        text: "기존 학생 테이블에 전화번호 컬럼을 추가하는 예시입니다.",
      },
      {
        type: "code",
        text: "ALTER TABLE 학생 ADD 전화번호 VARCHAR(15);",
      },
      {
        type: "subtitle",
        text: "예시 3: DROP TABLE",
      },
      {
        type: "paragraph",
        text: "학생 테이블을 삭제하는 예시입니다.",
      },
      {
        type: "code",
        text: "DROP TABLE 학생;",
      },
      {
        type: "subtitle",
        text: "예시 4: TRUNCATE TABLE",
      },
      {
        type: "paragraph",
        text: "학생 테이블의 모든 데이터를 삭제하지만 테이블 구조는 유지합니다.",
      },
      {
        type: "code",
        text: "TRUNCATE TABLE 학생;",
      },
      {
        type: "subtitle",
        text: "초기 데이터 예시: 학생 테이블",
      },
      {
        type: "table",
        headers: ["학번", "이름", "학과코드", "입학년도"],
        rows: [
          [101, "김민수", "CS", 2023],
          [102, "이영희", "EE", 2022],
          [103, "박철호", "ME", 2023],
        ],
        caption: "학생 테이블 초기 데이터",
      },
      {
        type: "subtitle",
        text: "ALTER TABLE 예시 결과",
      },
      {
        type: "paragraph",
        text: "전화번호 컬럼 추가 후, 데이터를 입력할 수 있습니다.",
      },
      {
        type: "code",
        text: "UPDATE 학생 SET 전화번호 = '010-1234-5678' WHERE 학번 = 101;",
      },
      {
        type: "table",
        headers: ["학번", "이름", "학과코드", "입학년도", "전화번호"],
        rows: [
          [101, "김민수", "CS", 2023, "010-1234-5678"],
          [102, "이영희", "EE", 2022, null],
          [103, "박철호", "ME", 2023, null],
        ],
        caption: "전화번호 컬럼 추가 후 데이터",
      },
      {
        type: "subtitle",
        text: "TRUNCATE TABLE 실행 후 데이터",
      },
      {
        type: "paragraph",
        text: "TRUNCATE 명령어 실행 후 학생 테이블의 데이터는 모두 삭제됩니다.",
      },
      {
        type: "table",
        headers: ["학번", "이름", "학과코드", "입학년도", "전화번호"],
        rows: [],
        caption: "TRUNCATE 실행 후 학생 테이블 데이터 없음",
      },
      {
        type: "subtitle",
        text: "DDL 사용 시 주의사항",
      },
      {
        type: "list",
        items: [
          "DROP 명령어를 사용하면 테이블과 데이터가 완전히 삭제되어 복구가 어렵습니다.",
          "ALTER로 컬럼을 삭제할 때는 데이터 손실에 주의하세요.",
          "TRUNCATE는 DELETE보다 빠르지만, 롤백이 제한적입니다.",
          "테이블 구조를 변경할 때는 데이터베이스 전체에 미치는 영향을 고려하세요.",
        ],
      },
      {
        type: "paragraph",
        text: "DDL은 데이터베이스 구조를 설계하고 관리하는 데 꼭 필요한 명령어입니다. SQLD 시험 준비를 위해 각 명령어의 역할과 결과를 충분히 연습해보세요.",
      },
    ],
  },
  DCL: {
    title: "DCL (Data Control Language) - 데이터 제어 언어",
    content: [
      {
        type: "paragraph",
        text: "DCL은 데이터베이스에서 사용자 권한을 관리하고, 데이터에 대한 접근과 조작 권한을 제어하는 명령어입니다. SQLD 자격증을 준비하는 고등학생이라면, 데이터베이스 보안을 위해 누가 어떤 권한을 가질 수 있는지 정확히 이해하는 것이 중요합니다.",
      },
      {
        type: "subtitle",
        text: "DCL의 주요 명령어",
      },
      {
        type: "table",
        headers: ["명령어", "역할", "설명"],
        rows: [
          [
            "GRANT",
            "권한 부여",
            "특정 사용자에게 데이터베이스 객체(테이블, 뷰 등)에 대한 권한을 부여함",
          ],
          ["REVOKE", "권한 회수", "사용자에게 부여한 권한을 취소함"],
        ],
        caption: "DCL의 주요 명령어",
      },
      {
        type: "subtitle",
        text: "예시 데이터: 학생 테이블",
      },
      {
        type: "table",
        headers: ["학번", "이름", "학과코드", "입학년도"],
        rows: [
          [101, "김민수", "CS", 2023],
          [102, "이영희", "EE", 2022],
          [103, "박철호", "ME", 2023],
          [104, "최지은", "CS", 2021],
        ],
        caption: "학생 테이블 초기 데이터",
      },
      {
        type: "subtitle",
        text: "1. 권한 부여 (GRANT)",
      },
      {
        type: "paragraph",
        text: "관리자가 사용자 'user1'에게 학생 테이블의 데이터를 조회할 수 있는 SELECT 권한을 부여합니다.",
      },
      {
        type: "code",
        text: "GRANT SELECT ON 학생 TO user1;",
      },
      {
        type: "paragraph",
        text: "'user1'은 권한을 부여받기 전에는 학생 테이블 데이터를 조회할 수 없습니다. 권한 부여 후 조회가 가능합니다.",
      },
      {
        type: "table",
        headers: ["사용자", "작업", "권한 여부", "조회 결과"],
        rows: [
          [
            "user1 (권한 없음)",
            "SELECT * FROM 학생;",
            "권한 없음",
            "접근 거부 (에러 발생)",
          ],
          [
            "user1 (권한 부여 후)",
            "SELECT * FROM 학생;",
            "권한 있음",
            "데이터 정상 조회 가능",
          ],
        ],
        caption: "권한 부여 전후의 조회 가능 여부",
      },
      {
        type: "subtitle",
        text: "2. 권한 회수 (REVOKE)",
      },
      {
        type: "paragraph",
        text: "관리자가 사용자 'user1'에게 부여한 SELECT 권한을 회수합니다.",
      },
      {
        type: "code",
        text: "REVOKE SELECT ON 학생 FROM user1;",
      },
      {
        type: "paragraph",
        text: "권한이 회수되면 'user1'은 다시 학생 테이블을 조회할 수 없습니다.",
      },
      {
        type: "table",
        headers: ["사용자", "작업", "권한 여부", "조회 결과"],
        rows: [
          [
            "user1 (권한 회수 후)",
            "SELECT * FROM 학생;",
            "권한 없음",
            "접근 거부 (에러 발생)",
          ],
        ],
        caption: "권한 회수 후 조회 불가",
      },
      {
        type: "subtitle",
        text: "DCL 사용 시 주의사항",
      },
      {
        type: "list",
        items: [
          "권한은 최소한으로 부여하여 데이터 보안을 강화해야 합니다.",
          "권한 회수 시, 해당 사용자가 수행하던 작업이 중단되지 않도록 신중하게 처리해야 합니다.",
          "GRANT, REVOKE 명령어는 데이터베이스 관리자(DBA) 또는 권한이 있는 사용자만 실행할 수 있습니다.",
          "SQLD 시험에서는 기본 문법과 역할 이해가 중요하며, 실제 상황에서 어떤 명령어를 사용하는지 숙지해야 합니다.",
        ],
      },
      {
        type: "paragraph",
        text: "DCL은 데이터베이스의 보안과 권한 관리를 담당하는 중요한 명령어입니다. SQLD 자격증 준비 시 꼭 익혀야 할 영역이며, 실무에서도 매우 자주 사용됩니다.",
      },
    ],
  },
  // 다른 주제들에 대한 내용은 계속 추가될 예정입니다.
  // 데이터 모델과 SQL, SQL 기본, SQL 활용, 관리 구문 등
};

export default studyContent;
