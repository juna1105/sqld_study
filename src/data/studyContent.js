// SQLD 학습 콘텐츠
const studyContent = {
  // 데이터 모델링의 이해
  엔티티: {
    title: "엔티티 (Entity)",
    content: [
      {
        type: "paragraph",
        text: "엔티티(Entity)란 정보 시스템에서 관리하고자 하는 대상을 말해요. 쉽게 말하면 데이터베이스에서 '테이블'로 만들어질 대상이라고 생각하면 됩니다.",
      },
      {
        type: "examples",
        text: "예를 들면, 학교 시스템에서는 '학생', '선생님', '과목', '교실' 등이 엔티티가 될 수 있어요.",
      },
      {
        type: "paragraph",
        text: "우리 주변의 모든 것이 엔티티가 될 수 있는데, 다음과 같은 조건을 만족해야 합니다:",
      },
      {
        type: "list",
        items: [
          "업무에서 필요하고 관리하고자 하는 정보여야 함 (시스템 개발에 필요한 것이어야 함)",
          "유일한 식별자(학번, 선생님 번호 등)에 의해 식별이 가능해야 함",
          "두 개 이상의 인스턴스(예: 여러 학생, 여러 선생님)가 존재해야 함",
          "업무 프로세스에 이용되어야 함",
          "반드시 속성(Attribute)을 가져야 함",
        ],
      },
      {
        type: "subtitle",
        text: "엔티티의 종류",
      },
      {
        type: "list",
        items: [
          "유형 엔티티: 물리적 형태가 있고 안정적이며 지속적으로 활용되는 엔티티 (학생, 교사, 상품 등)",
          "개념 엔티티: 물리적 형태는 없지만 개념적으로 존재하는 엔티티 (학과, 보험상품 등)",
          "사건 엔티티: 업무 수행에 따라 발생되는 엔티티 (주문, 수강신청, 성적 등)",
        ],
      },
      {
        type: "table",
        headers: ["엔티티 종류", "설명", "예시"],
        rows: [
          [
            "기본 엔티티",
            "업무에 기본적으로 필요하고 독립적으로 존재하는 엔티티",
            "학생, 교사, 부서",
          ],
          [
            "중심 엔티티",
            "기본 엔티티로부터 발생해 업무의 중심이 되는 엔티티",
            "주문, 수강신청, 성적",
          ],
          [
            "행위 엔티티",
            "두 개 이상의 엔티티로부터 발생되는 엔티티",
            "주문상세, 성적상세",
          ],
        ],
        caption: "엔티티의 세 가지 종류",
      },
      {
        type: "subtitle",
        text: "엔티티를 테이블로 변환",
      },
      {
        type: "paragraph",
        text: "엔티티는 데이터베이스 설계 시 테이블로 변환됩니다. 예를 들어, '학생' 엔티티는 데이터베이스에서 '학생 테이블'이 되고, 그 안에 여러 학생 정보가 들어가게 됩니다.",
      },
      {
        type: "table",
        headers: ["엔티티 예시", "변환된 테이블", "포함 데이터"],
        rows: [
          ["학생", "STUDENT 테이블", "모든 학생 정보"],
          ["교사", "TEACHER 테이블", "모든 교사 정보"],
          ["과목", "SUBJECT 테이블", "모든 과목 정보"],
          ["수강신청", "ENROLLMENT 테이블", "모든 수강신청 정보"],
        ],
        caption: "엔티티의 테이블 변환 예시",
      },
    ],
  },
  속성: {
    title: "속성 (Attribute)",
    content: [
      {
        type: "paragraph",
        text: "속성(Attribute)은 엔티티가 가지는 특성이나 성질을 의미해요. 쉽게 말해 테이블의 '컬럼(Column)'이 되는 것입니다.",
      },
      {
        type: "examples",
        text: "예: '학생' 엔티티의 속성으로는 '학번', '이름', '학년', '반', '주소', '전화번호' 등이 있을 수 있어요.",
      },
      {
        type: "paragraph",
        text: "속성은 업무에서 필요한 정보를 나타내며, 하나의 엔티티는 여러 개의 속성을 가질 수 있습니다.",
      },
      {
        type: "table",
        headers: ["엔티티", "속성들"],
        rows: [
          ["학생", "학번, 이름, 학년, 반, 주소, 전화번호, 이메일"],
          ["교사", "교사번호, 이름, 담당과목, 입사일, 연락처"],
          ["과목", "과목코드, 과목명, 학점, 개설학기"],
          ["수강신청", "수강신청번호, 학번, 과목코드, 신청일자, 이수구분"],
        ],
        caption: "엔티티별 속성 예시",
      },
      {
        type: "subtitle",
        text: "속성의 특징",
      },
      {
        type: "list",
        items: [
          "원자값(Atomic Value)을 가져야 합니다. 즉, 더 이상 쪼개질 수 없는 값이어야 합니다.",
          "주식별자에 함수적으로 종속되어야 합니다. (예: 학번이 정해지면 학생 이름이 결정됨)",
          "하나의 속성은 한 개의 값만 가져야 합니다. (다중값 속성은 별도의 엔티티로 분리해야 함)",
        ],
      },
      {
        type: "subtitle",
        text: "속성의 종류",
      },
      {
        type: "table",
        headers: ["속성 종류", "설명", "예시"],
        rows: [
          [
            "기본 속성",
            "업무로부터 추출한 일반적인 속성",
            "이름, 주소, 전화번호",
          ],
          ["설계 속성", "시스템 설계 시 도출되는 속성", "등록일자, 일련번호"],
          [
            "파생 속성",
            "다른 속성으로부터 계산되는 속성",
            "나이(생년월일로부터), 총액(수량×단가)",
          ],
          ["PK 속성", "엔티티를 식별하는 속성", "학번, 사원번호, 주문번호"],
          [
            "FK 속성",
            "다른 엔티티와의 관계를 나타내는 속성",
            "부서코드(사원 엔티티에서)",
          ],
        ],
        caption: "속성의 종류와 예시",
      },
      {
        type: "paragraph",
        text: "데이터베이스 설계 시 속성은 테이블의 컬럼이 되며, 각 컬럼은 특정 데이터 타입(숫자, 문자열, 날짜 등)을 가지게 됩니다.",
      },
      {
        type: "table",
        headers: ["속성명", "데이터 타입", "설명"],
        rows: [
          ["학번", "VARCHAR(10)", "학생 고유 식별자"],
          ["이름", "VARCHAR(50)", "학생 이름"],
          ["학년", "NUMBER(1)", "1~3학년"],
          ["입학일자", "DATE", "YYYY-MM-DD 형식의 날짜"],
          ["평균성적", "NUMBER(4,2)", "소수점 두 자리까지의 평균점수"],
        ],
        caption: "학생 테이블의 속성과 데이터 타입 예시",
      },
    ],
  },
  관계: {
    title: "관계 (Relationship)",
    content: [
      {
        type: "paragraph",
        text: "관계(Relationship)는 엔티티 간의 연관성을 나타내는 개념입니다. 예를 들어 '학생'과 '과목' 사이에는 '수강한다'라는 관계가 있을 수 있어요.",
      },
      {
        type: "examples",
        text: "예시: 학생은 여러 과목을 수강한다, 교사는 여러 반을 담당한다, 부서는 여러 사원을 가진다.",
      },
      {
        type: "paragraph",
        text: "관계는 보통 '동사'로 표현되며, 두 엔티티 간에 업무적 연관성이 있고 관련 행위가 지속적으로 이루어질 때 성립합니다.",
      },
      {
        type: "subtitle",
        text: "관계의 차수 (Cardinality)",
      },
      {
        type: "paragraph",
        text: "관계의 차수는 두 엔티티 간의 관계에서 참여자 수를 표현한 것입니다.",
      },
      {
        type: "table",
        headers: ["관계 차수", "설명", "예시"],
        rows: [
          [
            "1:1 (일대일)",
            "한 엔티티의 인스턴스가 다른 엔티티의 인스턴스와 단 하나만 연결됨",
            "학생과 학생증, 사람과 주민등록번호",
          ],
          [
            "1:N (일대다)",
            "한 엔티티의 하나의 인스턴스가 다른 엔티티의 여러 인스턴스와 연결됨",
            "학과와 학생, 부서와 사원",
          ],
          [
            "N:M (다대다)",
            "양쪽 엔티티의 인스턴스가 서로 여러 개와 연결됨",
            "학생과 과목, 주문과 상품",
          ],
        ],
        caption: "관계의 차수별 특징과 예시",
      },
      {
        type: "subtitle",
        text: "관계의 필수여부 (Optionality)",
      },
      {
        type: "paragraph",
        text: "관계의 필수여부는 특정 엔티티의 인스턴스가 반드시 다른 엔티티의 인스턴스와 관계를 맺어야 하는지 여부를 나타냅니다.",
      },
      {
        type: "table",
        headers: ["관계 필수여부", "설명", "예시"],
        rows: [
          [
            "필수적 관계",
            "반드시 관계를 맺어야 함 (NULL 값이 허용되지 않음)",
            "주문과 고객 (모든 주문은 반드시 고객이 있어야 함)",
          ],
          [
            "선택적 관계",
            "관계를 맺지 않아도 됨 (NULL 값이 허용됨)",
            "사원과 프로젝트 (사원이 프로젝트에 참여하지 않을 수도 있음)",
          ],
        ],
        caption: "관계의 필수여부 종류와 예시",
      },
      {
        type: "subtitle",
        text: "관계 표현 방법",
      },
      {
        type: "paragraph",
        text: "관계는 보통 ERD(Entity Relationship Diagram)에서 선으로 표현하며, 관계의 차수와 필수여부를 기호로 나타냅니다.",
      },
      {
        type: "table",
        headers: ["관계 종류", "데이터베이스 구현", "관계 예시"],
        rows: [
          [
            "1:1 관계",
            "한쪽 테이블의 PK를 다른 쪽 테이블의 PK 또는 FK로 설정",
            "학생-학생증",
          ],
          ["1:N 관계", "'일(1)' 쪽의 PK를 '다(N)' 쪽의 FK로 설정", "부서-사원"],
          [
            "N:M 관계",
            "관계를 표현하는 새로운 테이블 생성 (교차 테이블)",
            "학생-과목 → 수강신청 테이블",
          ],
        ],
        caption: "관계의 데이터베이스 구현 방법",
      },
      {
        type: "paragraph",
        text: "N:M(다대다) 관계는 실제 데이터베이스에서 직접 구현할 수 없어 중간에 연결 테이블을 만들어 두 개의 1:N 관계로 분해합니다.",
      },
      {
        type: "table",
        headers: ["관계 예시", "분해 방법", "연결 테이블"],
        rows: [
          [
            "학생과 과목(N:M)",
            "학생(1) : 수강신청(N), 과목(1) : 수강신청(N)",
            "수강신청(학번, 과목코드, 수강일자, 성적)",
          ],
          [
            "주문과 상품(N:M)",
            "주문(1) : 주문상세(N), 상품(1) : 주문상세(N)",
            "주문상세(주문번호, 상품코드, 수량, 단가)",
          ],
        ],
        caption: "N:M 관계의 분해 예시",
      },
    ],
  },
  식별자: {
    title: "식별자 (Identifier)",
    content: [
      {
        type: "paragraph",
        text: "식별자(Identifier)란 엔티티에서 각각의 인스턴스를 구별하는 데 사용되는 속성 또는 속성의 조합을 말합니다. 쉽게 말해 테이블의 '기본키(Primary Key)'가 되는 것이죠.",
      },
      {
        type: "examples",
        text: "예: 학생 엔티티의 식별자는 '학번', 직원 엔티티의 식별자는 '사원번호', 도서 엔티티의 식별자는 'ISBN'이 될 수 있습니다.",
      },
      {
        type: "subtitle",
        text: "식별자의 특징",
      },
      {
        type: "list",
        items: [
          "유일성(Unique): 엔티티 내에서 모든 인스턴스를 유일하게 구분할 수 있어야 합니다.",
          "최소성(Minimal): 꼭 필요한 최소한의 속성만으로 구성되어야 합니다.",
          "불변성(Stability): 식별자의 값은 자주 변경되지 않아야 합니다.",
          "존재성(Not Null): 모든 인스턴스는 반드시 식별자 값을 가져야 합니다.",
        ],
      },
      {
        type: "subtitle",
        text: "식별자의 종류",
      },
      {
        type: "table",
        headers: ["식별자 종류", "설명", "예시"],
        rows: [
          [
            "후보 식별자",
            "엔티티를 식별할 수 있는 여러 속성 중 하나",
            "학생 : 학번, 주민등록번호, (이름+학년+반)",
          ],
          [
            "기본 식별자(PK)",
            "후보 식별자 중 엔티티를 대표하는 식별자",
            "학생 : 학번",
          ],
          [
            "대체 식별자",
            "기본 식별자로 선택되지 않은 후보 식별자",
            "학생 : 주민등록번호",
          ],
          [
            "복합 식별자",
            "두 개 이상의 속성으로 구성된 식별자",
            "주문상세 : 주문번호 + 상품코드",
          ],
          [
            "외부 식별자(FK)",
            "다른 엔티티에서 가져온 식별자",
            "주문 : 고객ID (고객 엔티티에서 가져옴)",
          ],
        ],
        caption: "식별자의 종류별 특징과 예시",
      },
      {
        type: "subtitle",
        text: "본질식별자 vs 인조식별자",
      },
      {
        type: "paragraph",
        text: "식별자는 업무적으로 만들어지는 방식에 따라 본질식별자와 인조식별자로 나눌 수 있습니다.",
      },
      {
        type: "table",
        headers: ["구분", "설명", "예시", "장단점"],
        rows: [
          [
            "본질식별자",
            "업무에서 자연스럽게 만들어지는 식별자",
            "주민등록번호, ISBN",
            "업무 이해도 높음, 길이가 길거나 복잡할 수 있음",
          ],
          [
            "인조식별자",
            "시스템에서 임의로 만들어진 식별자",
            "일련번호, 자동증가값(Auto_increment)",
            "간결하고 사용이 편리하나 업무적 의미가 없음",
          ],
        ],
        caption: "본질식별자와 인조식별자 비교",
      },
      {
        type: "subtitle",
        text: "식별자 관계와 비식별자 관계",
      },
      {
        type: "paragraph",
        text: "두 엔티티 간의 관계에서 외래키(FK)가 기본키(PK)의 일부가 되는지 여부에 따라 식별자 관계와 비식별자 관계로 구분됩니다.",
      },
      {
        type: "table",
        headers: ["관계 유형", "설명", "예시"],
        rows: [
          [
            "식별자 관계",
            "부모 엔티티의 PK가 자식 엔티티의 PK 일부가 됨",
            "주문(주문번호) → 주문상세(주문번호+상품코드)",
          ],
          [
            "비식별자 관계",
            "부모 엔티티의 PK가 자식 엔티티의 일반 속성이 됨",
            "부서(부서번호) → 사원(사원번호, 부서번호)",
          ],
        ],
        caption: "식별자 관계와 비식별자 관계 비교",
      },
      {
        type: "paragraph",
        text: "식별자는 데이터베이스 설계에서 매우 중요한 요소로, 적절한 식별자 선택이 데이터베이스의 성능과 무결성에 큰 영향을 미칩니다.",
      },
    ],
  },
  // 데이터 모델과 SQL
  정규화: {
    title: "정규화 (Normalization)",
    content: [
      {
        type: "paragraph",
        text: "정규화(Normalization)는 데이터베이스의 테이블을 구조화하는 기법으로, 데이터 중복을 최소화하고 데이터 무결성을 보장하기 위한 과정이에요. 쉽게 말해 '데이터를 잘 정리정돈하는 방법'이라고 생각하면 됩니다.",
      },
      {
        type: "examples",
        text: "예를 들어, 학교 시스템에서 학생 정보와 수강 과목을 한 테이블에 모두 넣으면 같은 학생 정보가 여러 번 중복됩니다. 정규화는 이런 중복을 없애는 과정이에요.",
      },
      {
        type: "subtitle",
        text: "정규화가 필요한 이유",
      },
      {
        type: "list",
        items: [
          "데이터 중복 제거: 같은 데이터가 여러 곳에 저장되는 것을 방지",
          "데이터 일관성 유지: 한 곳만 수정해도 모든 관련 데이터가 함께 업데이트됨",
          "저장 공간 절약: 중복이 줄어들어 저장 공간이 효율적으로 사용됨",
          "데이터 구조의 변경이 쉬워짐: 새로운 요구사항에 맞춰 수정하기 용이",
        ],
      },
      {
        type: "paragraph",
        text: "정규화는 여러 단계(정규형)로 나뉘며, 각 단계마다 특정한 문제를 해결합니다. 주요 정규형에는 1NF, 2NF, 3NF, BCNF, 4NF, 5NF가 있지만, 실무에서는 보통 3NF나 BCNF까지만 적용하는 경우가 많습니다.",
      },
      {
        type: "subtitle",
        text: "제1정규형 (1NF)",
      },
      {
        type: "paragraph",
        text: "모든 속성이 원자값(더 이상 분해할 수 없는 값)만을 가지도록 테이블을 구성하는 것입니다. 즉, 하나의 컬럼에 여러 값이 들어가면 안 됩니다.",
      },
      {
        type: "table",
        headers: ["학번", "이름", "연락처"],
        rows: [
          ["1001", "김철수", "010-1234-5678, 02-123-4567"],
          ["1002", "이영희", "010-8765-4321"],
        ],
        caption: "1NF 위반 예시: 연락처 컬럼에 여러 값이 존재",
      },
      {
        type: "table",
        headers: ["학번", "이름", "연락처 유형", "연락처"],
        rows: [
          ["1001", "김철수", "휴대폰", "010-1234-5678"],
          ["1001", "김철수", "집전화", "02-123-4567"],
          ["1002", "이영희", "휴대폰", "010-8765-4321"],
        ],
        caption: "1NF 준수 예시: 각 레코드가 원자값만 포함",
      },
      {
        type: "subtitle",
        text: "제2정규형 (2NF)",
      },
      {
        type: "paragraph",
        text: "1NF를 만족하면서, 기본키가 아닌 모든 속성이 기본키에 완전 함수적 종속이어야 합니다. 쉽게 말해 테이블의 주제와 관련 없는 컬럼을 다른 테이블로 분리하는 것이에요.",
      },
      {
        type: "table",
        headers: ["학번", "과목코드", "학생이름", "과목명", "성적"],
        rows: [
          ["1001", "CS101", "김철수", "컴퓨터개론", "A+"],
          ["1001", "MA101", "김철수", "기초수학", "B+"],
          ["1002", "CS101", "이영희", "컴퓨터개론", "A"],
        ],
        caption:
          "2NF 위반 예시: 학생이름은 학번에만 종속, 과목명은 과목코드에만 종속",
      },
      {
        type: "table",
        headers: ["학번", "학생이름"],
        rows: [
          ["1001", "김철수"],
          ["1002", "이영희"],
        ],
        caption: "2NF 준수 예시 (학생 테이블)",
      },
      {
        type: "table",
        headers: ["과목코드", "과목명"],
        rows: [
          ["CS101", "컴퓨터개론"],
          ["MA101", "기초수학"],
        ],
        caption: "2NF 준수 예시 (과목 테이블)",
      },
      {
        type: "table",
        headers: ["학번", "과목코드", "성적"],
        rows: [
          ["1001", "CS101", "A+"],
          ["1001", "MA101", "B+"],
          ["1002", "CS101", "A"],
        ],
        caption: "2NF 준수 예시 (수강 테이블)",
      },
      {
        type: "subtitle",
        text: "제3정규형 (3NF)",
      },
      {
        type: "paragraph",
        text: "2NF를 만족하면서, 기본키가 아닌 모든 속성이 기본키에 이행적 함수 종속이 아니어야 합니다. 즉, 키가 아닌 컬럼이 다른 키가 아닌 컬럼에 의존하지 않아야 합니다.",
      },
      {
        type: "table",
        headers: ["학번", "이름", "학과코드", "학과명", "학과장"],
        rows: [
          ["1001", "김철수", "CS", "컴퓨터공학과", "박교수"],
          ["1002", "이영희", "CS", "컴퓨터공학과", "박교수"],
          ["1003", "박지민", "MA", "수학과", "김교수"],
        ],
        caption: "3NF 위반 예시: 학과명과 학과장은 학과코드에 종속됨",
      },
      {
        type: "table",
        headers: ["학번", "이름", "학과코드"],
        rows: [
          ["1001", "김철수", "CS"],
          ["1002", "이영희", "CS"],
          ["1003", "박지민", "MA"],
        ],
        caption: "3NF 준수 예시 (학생 테이블)",
      },
      {
        type: "table",
        headers: ["학과코드", "학과명", "학과장"],
        rows: [
          ["CS", "컴퓨터공학과", "박교수"],
          ["MA", "수학과", "김교수"],
        ],
        caption: "3NF 준수 예시 (학과 테이블)",
      },
      {
        type: "subtitle",
        text: "BCNF (Boyce-Codd 정규형)",
      },
      {
        type: "paragraph",
        text: "3NF를 만족하면서, 모든 결정자가 후보키여야 합니다. 결정자란 다른 컬럼의 값을 결정할 수 있는 컬럼을 말합니다.",
      },
      {
        type: "table",
        headers: ["학번", "과목코드", "교수코드", "교수명", "성적"],
        rows: [
          ["1001", "CS101", "P001", "김교수", "A+"],
          ["1002", "CS101", "P001", "김교수", "B+"],
          ["1001", "MA101", "P002", "이교수", "A"],
        ],
        caption:
          "BCNF 위반 예시: 교수코드가 결정자지만 후보키가 아님 (과목당 한 명의 교수만 담당)",
      },
      {
        type: "table",
        headers: ["과목코드", "교수코드"],
        rows: [
          ["CS101", "P001"],
          ["MA101", "P002"],
        ],
        caption: "BCNF 준수 예시 (과목-교수 테이블)",
      },
      {
        type: "table",
        headers: ["교수코드", "교수명"],
        rows: [
          ["P001", "김교수"],
          ["P002", "이교수"],
        ],
        caption: "BCNF 준수 예시 (교수 테이블)",
      },
      {
        type: "table",
        headers: ["학번", "과목코드", "성적"],
        rows: [
          ["1001", "CS101", "A+"],
          ["1002", "CS101", "B+"],
          ["1001", "MA101", "A"],
        ],
        caption: "BCNF 준수 예시 (수강 테이블)",
      },
      {
        type: "subtitle",
        text: "정규화의 장단점",
      },
      {
        type: "table",
        headers: ["장점", "단점"],
        rows: [
          ["데이터 중복 최소화", "테이블 수가 증가하여 조인 연산이 많아짐"],
          [
            "데이터 일관성과 무결성 유지",
            "일부 상황에서 조회 성능이 저하될 수 있음",
          ],
          ["데이터베이스 구조 변경 시 유연성 향상", "설계가 복잡해질 수 있음"],
          [
            "효율적인 저장 공간 활용",
            "극단적인 정규화는 실용성이 떨어질 수 있음",
          ],
        ],
        caption: "정규화의 장단점",
      },
      {
        type: "paragraph",
        text: "실제 데이터베이스 설계에서는 정규화를 통해 논리적으로 완벽한 구조를 만든 후, 필요에 따라 성능 향상을 위해 일부 역정규화(Denormalization)를 적용하기도 합니다. 역정규화는 의도적으로 중복을 허용하여 조회 성능을 높이는 기법입니다.",
      },
    ],
  },
  "관계와 조인의 이해": {
    title: "관계와 조인의 이해",
    content: [
      {
        type: "paragraph",
        text: "데이터베이스의 테이블들은 서로 관계를 맺고 있으며, 이 관계를 활용해 데이터를 함께 조회하는 것을 '조인(Join)'이라고 합니다. 쉽게 말해 여러 테이블에 흩어져 있는 정보를 하나로 모으는 작업이에요.",
      },
      {
        type: "examples",
        text: "예: 학생 테이블에는 학생의 기본 정보가, 성적 테이블에는 과목별 점수가 있다면, 조인을 통해 '김철수 학생의 모든 과목 성적'을 한 번에 조회할 수 있습니다.",
      },
      {
        type: "subtitle",
        text: "테이블 간 관계 유형",
      },
      {
        type: "table",
        headers: ["관계 유형", "설명", "예시"],
        rows: [
          [
            "1:1 (일대일)",
            "한 테이블의 레코드 하나가 다른 테이블의 레코드 하나와 연결됨",
            "사원-사원증, 학생-학생증",
          ],
          [
            "1:N (일대다)",
            "한 테이블의 레코드 하나가 다른 테이블의 여러 레코드와 연결됨",
            "학과-학생, 부서-사원",
          ],
          [
            "N:M (다대다)",
            "양쪽 테이블의 레코드가 서로 여러 개와 연결됨",
            "학생-과목, 주문-상품",
          ],
        ],
        caption: "테이블 간 관계 유형",
      },
      {
        type: "subtitle",
        text: "샘플 테이블 데이터",
      },
      {
        type: "paragraph",
        text: "아래 샘플 테이블을 통해 조인의 종류와 작동 방식을 이해해봅시다.",
      },
      {
        type: "table",
        headers: ["학번", "이름", "학과코드"],
        rows: [
          ["1001", "김철수", "CS"],
          ["1002", "이영희", "MA"],
          ["1003", "박지민", "CS"],
          ["1004", "최유진", "PH"],
        ],
        caption: "학생(STUDENT) 테이블",
      },
      {
        type: "table",
        headers: ["학과코드", "학과명", "위치"],
        rows: [
          ["CS", "컴퓨터공학과", "공학관 1층"],
          ["MA", "수학과", "이학관 2층"],
          ["EC", "경제학과", "사회관 3층"],
        ],
        caption: "학과(DEPARTMENT) 테이블",
      },
      {
        type: "subtitle",
        text: "조인의 종류",
      },
      {
        type: "paragraph",
        text: "조인에는 여러 종류가 있으며, 각 조인은 다른 방식으로 테이블을 연결합니다.",
      },
      {
        type: "list",
        items: [
          "내부 조인(Inner Join): 두 테이블에서 조건이 일치하는 행만 반환",
          "외부 조인(Outer Join): 한쪽 테이블의 모든 행을 포함하여 반환 (Left, Right, Full)",
          "교차 조인(Cross Join): 두 테이블의 모든 행을 조합하여 반환 (카티션 곱)",
          "셀프 조인(Self Join): 같은 테이블을 자기 자신과 조인",
        ],
      },
      {
        type: "subtitle",
        text: "내부 조인(Inner Join)",
      },
      {
        type: "paragraph",
        text: "내부 조인은 두 테이블에서 조인 조건을 만족하는 행만 결과에 포함합니다. 가장 많이 사용되는 조인 방식입니다.",
      },
      {
        type: "code",
        text: `SELECT S.학번, S.이름, S.학과코드, D.학과명, D.위치
FROM 학생 S
INNER JOIN 학과 D ON S.학과코드 = D.학과코드;`,
      },
      {
        type: "table",
        headers: ["학번", "이름", "학과코드", "학과명", "위치"],
        rows: [
          ["1001", "김철수", "CS", "컴퓨터공학과", "공학관 1층"],
          ["1002", "이영희", "MA", "수학과", "이학관 2층"],
          ["1003", "박지민", "CS", "컴퓨터공학과", "공학관 1층"],
        ],
        caption:
          "내부 조인 결과 (최유진 학생은 학과코드 PH가 학과 테이블에 없어서 제외됨)",
      },
      {
        type: "subtitle",
        text: "외부 조인(Outer Join)",
      },
      {
        type: "paragraph",
        text: "외부 조인은 한쪽 테이블의 모든 행을 포함하고, 다른 테이블에서 일치하는 행이 없으면 NULL 값을 채웁니다.",
      },
      {
        type: "subtitle",
        text: "좌측 외부 조인(Left Outer Join)",
      },
      {
        type: "code",
        text: `SELECT S.학번, S.이름, S.학과코드, D.학과명, D.위치
FROM 학생 S
LEFT OUTER JOIN 학과 D ON S.학과코드 = D.학과코드;`,
      },
      {
        type: "table",
        headers: ["학번", "이름", "학과코드", "학과명", "위치"],
        rows: [
          ["1001", "김철수", "CS", "컴퓨터공학과", "공학관 1층"],
          ["1002", "이영희", "MA", "수학과", "이학관 2층"],
          ["1003", "박지민", "CS", "컴퓨터공학과", "공학관 1층"],
          ["1004", "최유진", "PH", "NULL", "NULL"],
        ],
        caption: "좌측 외부 조인 결과 (학생 테이블의 모든 행 포함)",
      },
      {
        type: "subtitle",
        text: "우측 외부 조인(Right Outer Join)",
      },
      {
        type: "code",
        text: `SELECT S.학번, S.이름, D.학과코드, D.학과명, D.위치
FROM 학생 S
RIGHT OUTER JOIN 학과 D ON S.학과코드 = D.학과코드;`,
      },
      {
        type: "table",
        headers: ["학번", "이름", "학과코드", "학과명", "위치"],
        rows: [
          ["1001", "김철수", "CS", "컴퓨터공학과", "공학관 1층"],
          ["1003", "박지민", "CS", "컴퓨터공학과", "공학관 1층"],
          ["1002", "이영희", "MA", "수학과", "이학관 2층"],
          ["NULL", "NULL", "EC", "경제학과", "사회관 3층"],
        ],
        caption: "우측 외부 조인 결과 (학과 테이블의 모든 행 포함)",
      },
      {
        type: "subtitle",
        text: "완전 외부 조인(Full Outer Join)",
      },
      {
        type: "code",
        text: `SELECT S.학번, S.이름, COALESCE(S.학과코드, D.학과코드) AS 학과코드, D.학과명, D.위치
FROM 학생 S
FULL OUTER JOIN 학과 D ON S.학과코드 = D.학과코드;`,
      },
      {
        type: "table",
        headers: ["학번", "이름", "학과코드", "학과명", "위치"],
        rows: [
          ["1001", "김철수", "CS", "컴퓨터공학과", "공학관 1층"],
          ["1003", "박지민", "CS", "컴퓨터공학과", "공학관 1층"],
          ["1002", "이영희", "MA", "수학과", "이학관 2층"],
          ["1004", "최유진", "PH", "NULL", "NULL"],
          ["NULL", "NULL", "EC", "경제학과", "사회관 3층"],
        ],
        caption: "완전 외부 조인 결과 (양쪽 테이블의 모든 행 포함)",
      },
      {
        type: "subtitle",
        text: "교차 조인(Cross Join)",
      },
      {
        type: "paragraph",
        text: "교차 조인은 두 테이블의 모든 행을 조합한 결과를 반환합니다. 조인 조건이 없는 경우에 발생하며, 카티션 곱(Cartesian Product)이라고도 합니다.",
      },
      {
        type: "code",
        text: `SELECT S.이름, D.학과명
FROM 학생 S
CROSS JOIN 학과 D;`,
      },
      {
        type: "paragraph",
        text: "결과는 학생 테이블의 4행과 학과 테이블의 3행을 모두 조합한 12행(4×3)이 됩니다. 일반적으로 의도하지 않은 조인이므로 주의해야 합니다.",
      },
      {
        type: "subtitle",
        text: "셀프 조인(Self Join)",
      },
      {
        type: "paragraph",
        text: "셀프 조인은 같은 테이블을 자기 자신과 조인하는 방식입니다. 주로 계층 구조를 표현할 때 사용합니다.",
      },
      {
        type: "table",
        headers: ["사원번호", "사원명", "직급", "관리자번호"],
        rows: [
          ["E001", "김부장", "부장", "NULL"],
          ["E002", "이과장", "과장", "E001"],
          ["E003", "박대리", "대리", "E002"],
          ["E004", "최사원", "사원", "E003"],
        ],
        caption: "사원(EMPLOYEE) 테이블",
      },
      {
        type: "code",
        text: `SELECT E.사원번호, E.사원명 AS 사원, E.직급, M.사원명 AS 관리자, M.직급 AS 관리자직급
FROM 사원 E
LEFT JOIN 사원 M ON E.관리자번호 = M.사원번호;`,
      },
      {
        type: "table",
        headers: ["사원번호", "사원", "직급", "관리자", "관리자직급"],
        rows: [
          ["E001", "김부장", "부장", "NULL", "NULL"],
          ["E002", "이과장", "과장", "김부장", "부장"],
          ["E003", "박대리", "대리", "이과장", "과장"],
          ["E004", "최사원", "사원", "박대리", "대리"],
        ],
        caption: "셀프 조인 결과 (각 사원의 관리자 정보 표시)",
      },
      {
        type: "subtitle",
        text: "조인과 인덱스의 관계",
      },
      {
        type: "paragraph",
        text: "조인을 사용할 때는 조인 조건에 사용되는 컬럼에 인덱스를 생성하면 성능이 향상됩니다. 특히 대용량 테이블을 조인할 때 인덱스는 필수적입니다.",
      },
      {
        type: "paragraph",
        text: "조인은 데이터베이스에서 가장 많이 사용되는 연산 중 하나이지만, 테이블 수가 많아질수록 성능이 저하될 수 있습니다. 따라서 필요한 테이블만 조인하고, 적절한 조인 조건을 사용하는 것이 중요합니다.",
      },
    ],
  },
  "모델이 표현하는 트랜잭션의 이해": {
    title: "모델이 표현하는 트랜잭션의 이해",
    content: [
      {
        type: "paragraph",
        text: "데이터 모델은 단순히 데이터 구조만 표현하는 것이 아니라, 업무에서 발생하는 다양한 트랜잭션(Transaction)도 함께 표현합니다. 트랜잭션이란 데이터베이스에서 하나의 논리적 작업 단위를 말해요.",
      },
      {
        type: "examples",
        text: "예: 은행에서 계좌 이체는 하나의 트랜잭션으로, '출금 계좌에서 돈을 빼고, 입금 계좌에 돈을 넣는' 두 가지 작업이 모두 성공해야만 완료되는 하나의 작업입니다.",
      },
      {
        type: "subtitle",
        text: "트랜잭션의 특성 (ACID)",
      },
      {
        type: "list",
        items: [
          "원자성(Atomicity): 트랜잭션의 작업은 모두 성공하거나 모두 실패해야 함",
          "일관성(Consistency): 트랜잭션 실행 전후에 데이터베이스는 일관된 상태를 유지해야 함",
          "격리성(Isolation): 동시에 실행되는 트랜잭션들이 서로 영향을 주지 않아야 함",
          "지속성(Durability): 성공적으로 완료된 트랜잭션의 결과는 영구적으로 저장되어야 함",
        ],
      },
      {
        type: "subtitle",
        text: "데이터 모델에서 트랜잭션 표현 방법",
      },
      {
        type: "paragraph",
        text: "데이터 모델은 다음과 같은 방법으로 트랜잭션을 표현합니다.",
      },
      {
        type: "table",
        headers: ["표현 방법", "설명", "예시"],
        rows: [
          [
            "엔티티와 관계",
            "트랜잭션이 처리하는 데이터의 구조를 표현",
            "주문-주문상세-상품 관계는 '주문 처리' 트랜잭션을 지원",
          ],
          [
            "행위 엔티티",
            "트랜잭션의 결과로 생성되는 엔티티",
            "주문, 입금, 출금, 수강신청 등",
          ],
          [
            "상태 속성",
            "트랜잭션 처리 상태를 표현하는 속성",
            "주문상태(접수, 처리중, 완료), 결제상태(대기, 완료, 취소)",
          ],
          [
            "이력 엔티티",
            "트랜잭션의 이력을 저장하는 엔티티",
            "주문이력, 가격변동이력, 상태변경이력",
          ],
        ],
        caption: "데이터 모델에서 트랜잭션 표현 방법",
      },
      {
        type: "subtitle",
        text: "트랜잭션 모델링 예시 - 쇼핑몰 주문 처리",
      },
      {
        type: "paragraph",
        text: "쇼핑몰에서 고객이 상품을 주문하는 트랜잭션을 모델링해봅시다.",
      },
      {
        type: "table",
        headers: ["고객ID", "고객명", "이메일", "연락처"],
        rows: [
          ["C001", "김고객", "kim@example.com", "010-1234-5678"],
          ["C002", "이구매", "lee@example.com", "010-2345-6789"],
        ],
        caption: "고객(CUSTOMER) 테이블",
      },
      {
        type: "table",
        headers: ["상품코드", "상품명", "가격", "재고"],
        rows: [
          ["P001", "노트북", "1200000", "50"],
          ["P002", "스마트폰", "800000", "100"],
          ["P003", "이어폰", "50000", "200"],
        ],
        caption: "상품(PRODUCT) 테이블",
      },
      {
        type: "table",
        headers: ["주문번호", "고객ID", "주문일자", "주문상태", "총금액"],
        rows: [
          ["O001", "C001", "2023-05-10", "완료", "1250000"],
          ["O002", "C002", "2023-05-11", "처리중", "800000"],
        ],
        caption: "주문(ORDER) 테이블 - 행위 엔티티",
      },
      {
        type: "table",
        headers: ["주문번호", "상품코드", "수량", "단가", "금액"],
        rows: [
          ["O001", "P001", "1", "1200000", "1200000"],
          ["O001", "P003", "1", "50000", "50000"],
          ["O002", "P002", "1", "800000", "800000"],
        ],
        caption: "주문상세(ORDER_DETAIL) 테이블",
      },
      {
        type: "subtitle",
        text: "주문 처리 트랜잭션의 단계",
      },
      {
        type: "list",
        items: [
          "1. 고객이 상품을 선택하고 주문 요청",
          "2. 주문(ORDER) 레코드 생성 (주문상태: '접수')",
          "3. 주문상세(ORDER_DETAIL) 레코드 생성",
          "4. 상품(PRODUCT) 테이블의 재고 감소",
          "5. 결제 처리 후 주문상태 변경 (주문상태: '완료')",
        ],
      },
      {
        type: "subtitle",
        text: "트랜잭션을 지원하는 SQL",
      },
      {
        type: "code",
        text: `-- 트랜잭션 시작
BEGIN TRANSACTION;

-- 주문 정보 입력
INSERT INTO 주문(주문번호, 고객ID, 주문일자, 주문상태, 총금액)
VALUES('O003', 'C001', CURRENT_DATE, '접수', 1200000);

-- 주문 상세 정보 입력
INSERT INTO 주문상세(주문번호, 상품코드, 수량, 단가, 금액)
VALUES('O003', 'P001', 1, 1200000, 1200000);

-- 재고 감소
UPDATE 상품
SET 재고 = 재고 - 1
WHERE 상품코드 = 'P001';

-- 모든 작업이 성공적으로 수행되면 트랜잭션 완료
COMMIT;

-- 오류 발생 시 모든 변경사항 취소
-- ROLLBACK;`,
      },
      {
        type: "subtitle",
        text: "상태 다이어그램을 통한 트랜잭션 이해",
      },
      {
        type: "paragraph",
        text: "주문 처리 과정의 상태 변화를 다이어그램으로 표현하면 다음과 같습니다.",
      },
      {
        type: "table",
        headers: ["상태", "설명", "다음 상태"],
        rows: [
          ["접수", "주문이 시스템에 등록된 상태", "결제대기"],
          ["결제대기", "결제 처리를 기다리는 상태", "결제완료 또는 취소"],
          ["결제완료", "결제가 완료된 상태", "배송준비"],
          ["배송준비", "상품을 포장하고 출고 준비 중인 상태", "배송중"],
          ["배송중", "상품이 고객에게 배송 중인 상태", "배송완료"],
          ["배송완료", "상품이 고객에게 전달된 상태", "-"],
          ["취소", "주문이 취소된 상태", "-"],
        ],
        caption: "주문 처리의 상태 다이어그램",
      },
      {
        type: "subtitle",
        text: "이력 관리를 위한 모델링",
      },
      {
        type: "paragraph",
        text: "트랜잭션의 변화 이력을 관리하기 위해 이력 테이블을 추가할 수 있습니다.",
      },
      {
        type: "table",
        headers: [
          "이력ID",
          "주문번호",
          "변경일시",
          "이전상태",
          "변경상태",
          "처리자",
        ],
        rows: [
          ["H001", "O001", "2023-05-10 10:00:00", "NULL", "접수", "시스템"],
          ["H002", "O001", "2023-05-10 10:05:00", "접수", "결제대기", "시스템"],
          [
            "H003",
            "O001",
            "2023-05-10 10:10:00",
            "결제대기",
            "결제완료",
            "시스템",
          ],
          [
            "H004",
            "O001",
            "2023-05-10 14:00:00",
            "결제완료",
            "배송준비",
            "김직원",
          ],
          [
            "H005",
            "O001",
            "2023-05-11 09:00:00",
            "배송준비",
            "배송중",
            "이배송",
          ],
          [
            "H006",
            "O001",
            "2023-05-12 14:00:00",
            "배송중",
            "배송완료",
            "시스템",
          ],
        ],
        caption: "주문상태이력(ORDER_STATUS_HISTORY) 테이블",
      },
      {
        type: "subtitle",
        text: "트랜잭션 모델링의 이점",
      },
      {
        type: "list",
        items: [
          "데이터 정합성 유지: 관련 데이터가 모두 일관되게 처리됨",
          "업무 프로세스 파악 용이: 데이터 모델을 통해 업무 프로세스 이해 가능",
          "오류 추적 및 회복: 이력 관리를 통해 문제 발생 시 원인 파악 및 복구 가능",
          "성능 최적화: 트랜잭션 특성을 고려한 테이블 설계로 성능 향상 가능",
        ],
      },
      {
        type: "paragraph",
        text: "데이터 모델에서 트랜잭션을 적절히 표현하면 시스템의 안정성과 데이터 일관성을 유지할 수 있으며, 업무 요구사항을 더 정확하게 구현할 수 있습니다.",
      },
    ],
  },
  "NULL 속성의 이해": {
    title: "NULL 속성의 이해",
    content: [
      {
        type: "paragraph",
        text: "데이터베이스에서 NULL은 '값이 없음' 또는 '알 수 없음'을 나타내는 특별한 값입니다. NULL은 0이나 빈 문자열('')과는 다른 개념으로, 데이터 모델링과 SQL 작성 시 많은 주의가 필요합니다.",
      },
      {
        type: "examples",
        text: "예: 학생 테이블에서 휴대폰 번호가 아직 등록되지 않은 경우, 이 속성에는 NULL이 저장됩니다. 또한 직원의 퇴사일이 아직 정해지지 않았다면, 퇴사일 속성에도 NULL이 저장됩니다.",
      },
      {
        type: "subtitle",
        text: "NULL의 특성",
      },
      {
        type: "list",
        items: [
          "NULL은 '알 수 없는 값' 또는 '적용되지 않는 값'을 의미함",
          "NULL은 어떤 값과도 같지 않음 (NULL = NULL도 거짓임)",
          "NULL이 포함된 산술 연산의 결과는 NULL임",
          "NULL이 포함된 비교 연산은 UNKNOWN이라는 세 번째 논리값을 반환함",
        ],
      },
      {
        type: "subtitle",
        text: "NULL 이해를 위한 샘플 데이터",
      },
      {
        type: "table",
        headers: ["학번", "이름", "학과", "휴대폰", "동아리"],
        rows: [
          ["1001", "김철수", "컴퓨터공학", "010-1234-5678", "NULL"],
          ["1002", "이영희", "수학", "NULL", "밴드"],
          ["1003", "박지민", "물리학", "010-8765-4321", "축구"],
          ["1004", "최유진", "화학", "NULL", "NULL"],
        ],
        caption: "NULL을 포함하는 학생 테이블",
      },
      {
        type: "subtitle",
        text: "NULL과 관련된 SQL 연산",
      },
      {
        type: "paragraph",
        text: "NULL과 관련된 SQL 연산은 직관적이지 않을 수 있으므로 주의해야 합니다.",
      },
      {
        type: "subtitle",
        text: "1. 비교 연산자와 NULL",
      },
      {
        type: "code",
        text: `-- NULL과의 비교는 항상 UNKNOWN을 반환
SELECT * FROM 학생 WHERE 휴대폰 = NULL;  -- 결과 없음
SELECT * FROM 학생 WHERE 휴대폰 <> NULL; -- 결과 없음

-- NULL 비교는 IS NULL 또는 IS NOT NULL 연산자 사용
SELECT * FROM 학생 WHERE 휴대폰 IS NULL;      -- 이영희, 최유진 반환
SELECT * FROM 학생 WHERE 휴대폰 IS NOT NULL;  -- 김철수, 박지민 반환`,
      },
      {
        type: "subtitle",
        text: "2. 함수와 NULL",
      },
      {
        type: "code",
        text: `-- 집계 함수는 NULL을 무시함
SELECT COUNT(*) FROM 학생;            -- 결과: 4 (모든 행 수)
SELECT COUNT(휴대폰) FROM 학생;       -- 결과: 2 (NULL이 아닌 휴대폰 수)

-- NULL을 다른 값으로 대체하는 함수: COALESCE, NVL, IFNULL
SELECT 이름, COALESCE(휴대폰, '연락처 없음') FROM 학생;
-- Oracle: NVL(휴대폰, '연락처 없음')
-- MySQL: IFNULL(휴대폰, '연락처 없음')`,
      },
      {
        type: "subtitle",
        text: "3. 논리 연산자와 NULL",
      },
      {
        type: "paragraph",
        text: "SQL의 논리 연산은 3-값 논리(TRUE, FALSE, UNKNOWN)를 사용합니다.",
      },
      {
        type: "table",
        headers: ["연산", "결과"],
        rows: [
          ["TRUE AND UNKNOWN", "UNKNOWN"],
          ["FALSE AND UNKNOWN", "FALSE"],
          ["TRUE OR UNKNOWN", "TRUE"],
          ["FALSE OR UNKNOWN", "UNKNOWN"],
          ["NOT UNKNOWN", "UNKNOWN"],
        ],
        caption: "3-값 논리 결과표",
      },
      {
        type: "code",
        text: `-- 3-값 논리로 인한 의외의 결과
SELECT * FROM 학생 WHERE 휴대폰 = '010-1234-5678' OR 휴대폰 <> '010-1234-5678';
-- 김철수, 박지민만 반환 (NULL인 이영희, 최유진은 포함되지 않음)

-- 원하는 결과를 얻으려면 NULL 처리 필요
SELECT * FROM 학생 
WHERE 휴대폰 = '010-1234-5678' 
OR 휴대폰 <> '010-1234-5678' 
OR 휴대폰 IS NULL;`,
      },
      {
        type: "subtitle",
        text: "데이터 모델링에서 NULL 처리",
      },
      {
        type: "list",
        items: [
          "NOT NULL 제약조건: 중요한 속성은 NULL을 허용하지 않도록 설계",
          "기본값(DEFAULT) 설정: NULL 대신 의미 있는 기본값 사용",
          "외래키와 NULL: 선택적 관계에서는 외래키에 NULL 허용",
          "복합 키와 NULL: 복합 키의 일부가 NULL이면 식별 불가능",
        ],
      },
      {
        type: "table",
        headers: ["상황", "NULL 허용", "NOT NULL + 기본값", "NOT NULL 제약"],
        rows: [
          [
            "아직 값이 정해지지 않음",
            "입학예정자의 학번",
            "가입일(현재 날짜)",
            "이름(필수입력)",
          ],
          ["해당사항 없음", "미혼자의 배우자명", "할인율(0%)", "-"],
          ["알 수 없음", "연락처(미입력)", "-", "-"],
        ],
        caption: "상황별 NULL 처리 방법",
      },
      {
        type: "subtitle",
        text: "NULL 관련 주의사항",
      },
      {
        type: "list",
        items: [
          "인덱스 효율: NULL 값이 많은 컬럼에 인덱스를 생성하면 효율이 떨어짐",
          "조인 조건: 조인 컬럼에 NULL이 있으면 일치하는 행이 제외될 수 있음",
          "그룹화: NULL은 그룹화 시 하나의 그룹으로 처리됨",
          "복합 인덱스: NULL이 포함된 복합 인덱스는 일부 DBMS에서 제대로 작동하지 않을 수 있음",
        ],
      },
      {
        type: "subtitle",
        text: "NULL을 포함한 그룹화 및 정렬",
      },
      {
        type: "code",
        text: `-- 그룹화: NULL은 하나의 그룹으로 처리됨
SELECT 동아리, COUNT(*) AS 학생수
FROM 학생
GROUP BY 동아리;

-- 결과:
-- 동아리 | 학생수
-- NULL  | 2
-- 밴드   | 1
-- 축구   | 1

-- 정렬: NULL은 DBMS에 따라 처리가 다름
-- Oracle: NULL은 가장 큰 값으로 처리 (오름차순 정렬 시 마지막)
-- MySQL, SQL Server: NULL은 가장 작은 값으로 처리 (오름차순 정렬 시 처음)

-- NULL 정렬 위치 명시
SELECT 이름, 동아리
FROM 학생
ORDER BY 동아리 NULLS FIRST;  -- NULL을 처음에 정렬 (Oracle)

SELECT 이름, 동아리
FROM 학생
ORDER BY 동아리 NULLS LAST;   -- NULL을 마지막에 정렬 (Oracle)

-- MySQL, SQL Server에서는 CASE 표현식 사용
SELECT 이름, 동아리
FROM 학생
ORDER BY CASE WHEN 동아리 IS NULL THEN 1 ELSE 0 END, 동아리;  -- NULL을 처음에 정렬`,
      },
      {
        type: "subtitle",
        text: "실무에서의 NULL 처리 전략",
      },
      {
        type: "list",
        items: [
          "식별자와 필수 데이터에는 NOT NULL 제약조건 적용",
          "날짜, 수량 등 계산에 사용되는 컬럼은 기본값 설정",
          "NULL 대신 특수값 사용 고려 (예: 알 수 없는 전화번호 → '000-0000-0000')",
          "애플리케이션 레벨에서 NULL 값 검증 및 처리",
        ],
      },
      {
        type: "paragraph",
        text: "NULL은 데이터베이스에서 중요한 개념이지만, 잘못 처리하면 예상치 못한 결과를 가져올 수 있습니다. 데이터 모델링 단계에서 NULL 허용 여부를 신중하게 결정하고, SQL 작성 시 NULL 처리 방법을 정확히 이해하는 것이 중요합니다.",
      },
    ],
  },
  "본질식별자 VS 인조식별자": {
    title: "본질식별자 VS 인조식별자",
    content: [
      {
        type: "paragraph",
        text: "데이터베이스 설계에서 테이블의 기본키(Primary Key)를 선택할 때 '본질식별자'와 '인조식별자' 중 어떤 것을 사용할지는 중요한 결정입니다. 두 접근 방식은 각각 장단점이 있으며, 상황에 따라 적절한 선택이 달라집니다.",
      },
      {
        type: "subtitle",
        text: "식별자의 개념과 종류",
      },
      {
        type: "list",
        items: [
          "본질식별자(Natural Key): 업무에서 자연스럽게 발생하여 의미를 갖는 식별자",
          "인조식별자(Surrogate Key): 시스템에서 임의로 생성한 의미 없는 식별자",
        ],
      },
      {
        type: "table",
        headers: ["종류", "의미", "예시"],
        rows: [
          [
            "본질식별자",
            "업무적으로 의미가 있으며 자연스럽게 생성되는 식별자",
            "주민등록번호, ISBN, 상품코드, 학번",
          ],
          [
            "인조식별자",
            "시스템에서 생성한 임의의 값으로 업무적 의미가 없는 식별자",
            "자동증가 정수(Auto Increment), UUID, 일련번호",
          ],
        ],
        caption: "본질식별자와 인조식별자의 기본 개념",
      },
      {
        type: "subtitle",
        text: "본질식별자(Natural Key)의 특징",
      },
      {
        type: "list",
        items: [
          "업무적 의미가 있어서 직관적으로 이해하기 쉬움",
          "별도의 컬럼을 추가할 필요가 없어 저장 공간 효율적",
          "현실 세계의 개념을 그대로 데이터베이스에 반영",
          "관련 엔티티와의 관계에서 식별관계 구성 가능",
        ],
      },
      {
        type: "table",
        headers: ["장점", "단점"],
        rows: [
          [
            "업무적 의미 파악이 용이함",
            "값이 길거나 복잡할 수 있음(예: 주민등록번호)",
          ],
          [
            "추가 컬럼 없이 바로 식별자로 사용 가능",
            "업무 변경 시 식별자도 변경될 가능성 있음",
          ],
          [
            "실제 비즈니스 룰을 데이터베이스에 반영",
            "복합키로 구성되면 관리가 복잡해짐",
          ],
          [
            "데이터 모델의 직관성 향상",
            "외래키 참조 시 더 많은 저장 공간 필요",
          ],
        ],
        caption: "본질식별자의 장단점",
      },
      {
        type: "subtitle",
        text: "인조식별자(Surrogate Key)의 특징",
      },
      {
        type: "list",
        items: [
          "일반적으로 단순한 숫자나 UUID 형태로 생성됨",
          "업무 변경에 영향을 받지 않는 안정적인 구조",
          "테이블 간 조인이 간단해지고 성능이 향상될 수 있음",
          "자동 생성되므로 별도 관리가 필요 없음",
        ],
      },
      {
        type: "table",
        headers: ["장점", "단점"],
        rows: [
          [
            "값이 단순하고 인덱싱 효율이 좋음",
            "업무적 의미가 없어 직관성이 떨어짐",
          ],
          ["업무 변경에 영향을 받지 않음", "추가 컬럼으로 저장 공간 사용"],
          [
            "외래키 참조가 간단해짐",
            "원본 데이터를 확인하기 위한 추가 조회 필요",
          ],
          [
            "단일 컬럼으로 복합키 문제 해결",
            "실제 업무와 데이터 모델 간 괴리 발생",
          ],
        ],
        caption: "인조식별자의 장단점",
      },
      {
        type: "subtitle",
        text: "실제 테이블 예시 - 본질식별자",
      },
      {
        type: "paragraph",
        text: "학생 테이블에서 학번을 본질식별자로 사용한 예시",
      },
      {
        type: "table",
        headers: ["학번(PK)", "이름", "학과", "입학년도"],
        rows: [
          ["2023001", "김철수", "컴퓨터공학", "2023"],
          ["2023002", "이영희", "수학", "2023"],
          ["2022001", "박지민", "물리학", "2022"],
        ],
        caption: "본질식별자(학번)를 사용한 학생 테이블",
      },
      {
        type: "table",
        headers: ["학번(FK)", "과목코드", "학년도", "학기", "성적"],
        rows: [
          ["2023001", "CS101", "2023", "1", "A+"],
          ["2023001", "MA101", "2023", "1", "B+"],
          ["2023002", "MA101", "2023", "1", "A"],
        ],
        caption: "본질식별자를 참조하는 수강내역 테이블",
      },
      {
        type: "subtitle",
        text: "실제 테이블 예시 - 인조식별자",
      },
      {
        type: "paragraph",
        text: "학생 테이블에서 자동 증가 ID를 인조식별자로 사용한 예시",
      },
      {
        type: "table",
        headers: ["ID(PK)", "학번", "이름", "학과", "입학년도"],
        rows: [
          ["1", "2023001", "김철수", "컴퓨터공학", "2023"],
          ["2", "2023002", "이영희", "수학", "2023"],
          ["3", "2022001", "박지민", "물리학", "2022"],
        ],
        caption: "인조식별자(ID)를 사용한 학생 테이블",
      },
      {
        type: "table",
        headers: ["ID(PK)", "학생ID(FK)", "과목코드", "학년도", "학기", "성적"],
        rows: [
          ["1", "1", "CS101", "2023", "1", "A+"],
          ["2", "1", "MA101", "2023", "1", "B+"],
          ["3", "2", "MA101", "2023", "1", "A"],
        ],
        caption: "인조식별자를 참조하는 수강내역 테이블",
      },
      {
        type: "subtitle",
        text: "식별관계와 비식별관계",
      },
      {
        type: "paragraph",
        text: "식별자 선택은 테이블 간의 관계 유형에도 영향을 미칩니다.",
      },
      {
        type: "table",
        headers: ["관계 유형", "정의", "특징", "예시"],
        rows: [
          [
            "식별관계",
            "부모 테이블의 기본키가 자식 테이블의 기본키이자 외래키가 됨",
            "강한 연관성, 종속적인 관계를 표현",
            "주문-주문상세(주문번호가 주문상세의 PK 일부)",
          ],
          [
            "비식별관계",
            "부모 테이블의 기본키가 자식 테이블의 일반 속성으로 참조됨",
            "약한 연관성, 독립적인 관계를 표현",
            "부서-사원(부서번호가 사원 테이블의 일반 속성)",
          ],
        ],
        caption: "식별관계와 비식별관계 비교",
      },
      {
        type: "subtitle",
        text: "본질식별자와 인조식별자 선택 기준",
      },
      {
        type: "list",
        items: [
          "테이블의 특성과 용도: 트랜잭션 테이블은 인조식별자가 유리할 수 있음",
          "성능 요구사항: 대용량 테이블은 단순한 인조식별자가 유리",
          "데이터 통합 요구사항: 여러 시스템 연계 시 본질식별자가 도움이 될 수 있음",
          "업무 규칙의 안정성: 빈번한 변경이 예상되면 인조식별자 고려",
        ],
      },
      {
        type: "table",
        headers: ["상황", "권장 식별자", "이유"],
        rows: [
          [
            "업무적으로 이미 식별자가 확립됨",
            "본질식별자",
            "기존 업무 흐름과 일치, 직관적 이해 가능",
          ],
          [
            "대용량 데이터 처리 필요",
            "인조식별자",
            "단순 정수형으로 인덱싱 효율 높음",
          ],
          [
            "식별자가 자주 변경될 가능성",
            "인조식별자",
            "업무 변경에 영향받지 않는 안정적 구조",
          ],
          [
            "여러 시스템 통합 환경",
            "상황에 따라 다름",
            "시스템 간 통합 요구사항 고려 필요",
          ],
        ],
        caption: "상황별 식별자 선택 가이드",
      },
      {
        type: "subtitle",
        text: "실무 사례 분석",
      },
      {
        type: "paragraph",
        text: "인터넷 쇼핑몰 데이터베이스의 식별자 선택 예시",
      },
      {
        type: "table",
        headers: ["테이블", "본질식별자 사용", "인조식별자 사용", "권장"],
        rows: [
          [
            "고객",
            "이메일(중복 가능성 낮음)",
            "고객ID(자동증가)",
            "인조식별자(개인정보 보호, 변경 가능성)",
          ],
          [
            "상품",
            "상품코드(체계적 관리 가능)",
            "상품ID(자동증가)",
            "본질식별자(업무에서 이미 사용 중인 코드)",
          ],
          [
            "주문",
            "주문번호(업무규칙 반영)",
            "주문ID(자동증가)",
            "상황에 따라 다름(주문번호 체계에 따라)",
          ],
          [
            "주문상세",
            "주문번호+상품코드(복합키)",
            "주문상세ID(자동증가)",
            "인조식별자(복합키 관리 복잡성 해소)",
          ],
        ],
        caption: "쇼핑몰 데이터베이스의 식별자 선택 예시",
      },
      {
        type: "subtitle",
        text: "결론",
      },
      {
        type: "paragraph",
        text: "본질식별자와 인조식별자는 각각 장단점이 있으며, 어느 것이 더 좋은지는 상황에 따라 다릅니다. 데이터베이스 설계 시 업무 특성, 성능 요구사항, 유지보수 용이성 등을 종합적으로 고려하여 식별자를 선택해야 합니다. 또한 일부 테이블에는 본질식별자를, 다른 테이블에는 인조식별자를 사용하는 혼합 접근 방식도 가능합니다.",
      },
      {
        type: "paragraph",
        text: "최근에는 많은 시스템에서 인조식별자를 선호하는 경향이 있지만, 업무 규칙이 명확하고 안정적인 경우에는 본질식별자도 여전히 유효한 선택입니다. 중요한 것은 프로젝트의 요구사항과 특성에 맞게 적절한 식별자를 선택하는 것입니다.",
      },
    ],
  },
  // SQL 기본
  "관계형 데이터베이스 개요": {
    title: "관계형 데이터베이스 개요",
    content: [
      {
        type: "paragraph",
        text: "관계형 데이터베이스(Relational Database)는 테이블 형태로 데이터를 저장하고, 테이블 간의 관계를 이용해 데이터를 관리하는 데이터베이스 시스템입니다. 오늘날 가장 널리 사용되는 데이터베이스 유형입니다.",
      },
      {
        type: "examples",
        text: "우리가 일상에서 사용하는 대부분의 서비스(인터넷 쇼핑몰, 학교 성적 관리, 은행 거래 시스템 등)는 관계형 데이터베이스를 사용하고 있어요.",
      },
      {
        type: "subtitle",
        text: "관계형 데이터베이스의 특징",
      },
      {
        type: "list",
        items: [
          "데이터를 테이블(행과 열)로 구성: 직관적이고 이해하기 쉬운 구조",
          "여러 테이블 간의 관계를 통해 데이터 참조 가능",
          "SQL(Structured Query Language)을 사용하여 데이터 조작",
          "ACID 특성(원자성, 일관성, 격리성, 지속성)을 보장하여 데이터 신뢰성 확보",
          "데이터의 중복을 최소화하고 무결성을 유지하는 정규화 기법 적용",
        ],
      },
      {
        type: "subtitle",
        text: "관계형 데이터베이스의 기본 용어",
      },
      {
        type: "table",
        headers: ["용어", "설명", "예시"],
        rows: [
          [
            "테이블(Table)",
            "데이터를 저장하는 기본 단위, 행과 열로 구성됨",
            "학생 테이블, 상품 테이블",
          ],
          [
            "행(Row)/레코드(Record)",
            "테이블의 가로줄, 하나의 데이터 단위",
            "하나의 학생 정보, 하나의 주문 정보",
          ],
          [
            "열(Column)/필드(Field)",
            "테이블의 세로줄, 특정 속성을 나타냄",
            "이름, 학번, 전화번호",
          ],
          [
            "기본키(Primary Key)",
            "각 행을 고유하게 식별하는 열 또는 열의 조합",
            "학번, 주문번호, 사원번호",
          ],
          [
            "외래키(Foreign Key)",
            "다른 테이블의 기본키를 참조하는 열",
            "학생 테이블의 학과코드(학과 테이블 참조)",
          ],
          [
            "스키마(Schema)",
            "데이터베이스의 구조와 제약조건 정의",
            "테이블 구조, 관계, 규칙의 집합",
          ],
        ],
        caption: "관계형 데이터베이스의 주요 용어",
      },
      {
        type: "subtitle",
        text: "주요 관계형 데이터베이스 관리 시스템(RDBMS)",
      },
      {
        type: "table",
        headers: ["RDBMS", "개발사", "특징"],
        rows: [
          [
            "Oracle",
            "Oracle Corporation",
            "대규모 기업용 DBMS, 높은 안정성과 성능, 고가의 라이선스",
          ],
          [
            "MySQL",
            "Oracle Corporation (이전 MySQL AB)",
            "오픈 소스 DBMS, 웹 애플리케이션에 많이 사용, 빠른 읽기 성능",
          ],
          [
            "SQL Server",
            "Microsoft",
            "윈도우 환경에 최적화, MS 제품과 잘 통합됨",
          ],
          [
            "PostgreSQL",
            "PostgreSQL Global Development Group",
            "오픈 소스 DBMS, 고급 기능 지원, 복잡한 쿼리에 강점",
          ],
          [
            "SQLite",
            "D. Richard Hipp",
            "파일 기반 경량 DBMS, 내장형 애플리케이션에 적합",
          ],
        ],
        caption: "주요 관계형 데이터베이스 관리 시스템 비교",
      },
      {
        type: "subtitle",
        text: "SQL 개요",
      },
      {
        type: "paragraph",
        text: "SQL(Structured Query Language)은 관계형 데이터베이스를 관리하고 데이터를 조작하기 위한 표준 언어입니다. SQL은 크게 다음과 같은 범주로 나눌 수 있습니다.",
      },
      {
        type: "table",
        headers: ["분류", "역할", "주요 명령어"],
        rows: [
          ["DQL (Data Query Language)", "데이터 조회", "SELECT (데이터 조회)"],
          [
            "DML (Data Manipulation Language)",
            "데이터 조작",
            "INSERT (삽입), UPDATE (수정), DELETE (삭제)",
          ],
          [
            "DDL (Data Definition Language)",
            "데이터 정의",
            "CREATE (생성), ALTER (변경), DROP (삭제), TRUNCATE (비우기)",
          ],
          [
            "DCL (Data Control Language)",
            "데이터 제어",
            "GRANT (권한 부여), REVOKE (권한 회수)",
          ],
          [
            "TCL (Transaction Control Language)",
            "트랜잭션 제어",
            "COMMIT (확정), ROLLBACK (취소), SAVEPOINT (저장점 생성)",
          ],
        ],
        caption: "SQL 명령어 분류",
      },
      {
        type: "subtitle",
        text: "관계형 데이터베이스의 장단점",
      },
      {
        type: "table",
        headers: ["장점", "단점"],
        rows: [
          [
            "데이터의 일관성과 정확성 보장",
            "대용량 데이터 처리 시 성능 저하 가능",
          ],
          ["표준화된 SQL을 통한 접근 용이", "수평적 확장(Scale-out)이 어려움"],
          [
            "복잡한 쿼리와 트랜잭션 처리 가능",
            "유연하지 않은 스키마 구조 (변경 비용 높음)",
          ],
          [
            "데이터 중복 최소화로 저장 공간 절약",
            "객체 지향 프로그래밍과의 임피던스 불일치",
          ],
          ["데이터 무결성과 보안 강화", "비정형 데이터 처리에 불리함"],
        ],
        caption: "관계형 데이터베이스의 장단점",
      },
      {
        type: "subtitle",
        text: "관계형 모델의 발전",
      },
      {
        type: "paragraph",
        text: "관계형 데이터베이스는 1970년 E.F. Codd가 관계 모델을 제안하면서 시작되었습니다. 이후 수십 년 동안 발전하여 현재 데이터 관리의 표준이 되었습니다. 최근에는 빅데이터, 실시간 처리, 비정형 데이터 등의 요구사항에 대응하기 위해 NoSQL, NewSQL 등 새로운 데이터베이스 모델도 등장했지만, 여전히 많은 시스템에서 관계형 데이터베이스는 핵심적인 역할을 수행하고 있습니다.",
      },
      {
        type: "subtitle",
        text: "관계형 데이터베이스 예시 - 학교 데이터베이스",
      },
      {
        type: "table",
        headers: ["학번", "이름", "학과코드", "학년", "생년월일"],
        rows: [
          ["2023001", "김철수", "CS", "1", "2004-05-10"],
          ["2023002", "이영희", "MA", "1", "2004-08-15"],
          ["2022001", "박지민", "CS", "2", "2003-01-22"],
          ["2022002", "최유진", "PH", "2", "2003-11-07"],
        ],
        caption: "학생(STUDENT) 테이블",
      },
      {
        type: "table",
        headers: ["학과코드", "학과명", "위치", "전화번호"],
        rows: [
          ["CS", "컴퓨터공학과", "공학관 1층", "02-1234-5678"],
          ["MA", "수학과", "이학관 2층", "02-1234-5679"],
          ["PH", "물리학과", "이학관 3층", "02-1234-5680"],
        ],
        caption: "학과(DEPARTMENT) 테이블",
      },
      {
        type: "table",
        headers: ["과목코드", "과목명", "학점", "담당교수"],
        rows: [
          ["CS101", "프로그래밍 기초", "3", "김교수"],
          ["CS102", "자료구조", "3", "박교수"],
          ["MA101", "미적분학", "3", "이교수"],
          ["PH101", "일반물리학", "3", "최교수"],
        ],
        caption: "과목(COURSE) 테이블",
      },
      {
        type: "table",
        headers: ["수강번호", "학번", "과목코드", "년도", "학기", "성적"],
        rows: [
          ["1", "2023001", "CS101", "2023", "1", "A+"],
          ["2", "2023001", "MA101", "2023", "1", "B+"],
          ["3", "2023002", "MA101", "2023", "1", "A"],
          ["4", "2022001", "CS102", "2023", "1", "A"],
        ],
        caption: "수강(ENROLLMENT) 테이블",
      },
      {
        type: "paragraph",
        text: "위의 테이블들은 관계를 통해 연결되어 있습니다. 예를 들어, 학생 테이블의 '학과코드'는 학과 테이블의 '학과코드'를 참조하는 외래키이며, 수강 테이블의 '학번'과 '과목코드'는 각각 학생 테이블과 과목 테이블을 참조하는 외래키입니다. 이러한 관계를 통해 '김철수 학생이 수강 중인 모든 과목 조회', '컴퓨터공학과 학생들의 평균 성적 계산' 등의 복잡한 정보를 추출할 수 있습니다.",
      },
    ],
  },
  함수: {
    title: "SQL 함수 (Functions)",
    content: [
      {
        type: "paragraph",
        text: "SQL 함수는 데이터베이스에서 데이터를 처리하고 변환하는 데 사용되는 내장 기능입니다. 함수를 사용하면 복잡한 계산, 문자열 조작, 날짜 처리 등을 간단하게 수행할 수 있습니다.",
      },
      {
        type: "examples",
        text: "예: 학생들의 평균 성적을 계산하거나(AVG 함수), 이름의 첫 글자만 대문자로 변환하거나(INITCAP 함수), 오늘 날짜로부터 30일 후의 날짜를 계산하는 등(ADD_MONTHS 함수)의 작업을 함수로 쉽게 처리할 수 있습니다.",
      },
      {
        type: "subtitle",
        text: "SQL 함수의 종류",
      },
      {
        type: "list",
        items: [
          "단일행 함수(Single-Row Functions): 입력 행마다 하나의 결과를 반환",
          "집계 함수(Aggregate Functions): 여러 행의 값을 그룹화하여 하나의 결과를 반환",
          "분석 함수(Analytic Functions): 집계와 유사하지만 행 단위 처리가 가능한 함수",
          "윈도우 함수(Window Functions): 행들의 그룹(윈도우)에 대한 계산을 수행하는 함수",
        ],
      },
      {
        type: "subtitle",
        text: "1. 단일행 함수 (Single-Row Functions)",
      },
      {
        type: "paragraph",
        text: "단일행 함수는 각 행에 대해 하나의 결과를 반환합니다. 주요 단일행 함수는 다음과 같습니다.",
      },
      {
        type: "subtitle",
        text: "1.1 문자 함수",
      },
      {
        type: "table",
        headers: ["함수", "설명", "예시", "결과"],
        rows: [
          [
            "UPPER(문자열)",
            "모든 문자를 대문자로 변환",
            "UPPER('Hello')",
            "HELLO",
          ],
          [
            "LOWER(문자열)",
            "모든 문자를 소문자로 변환",
            "LOWER('Hello')",
            "hello",
          ],
          [
            "SUBSTR(문자열, 위치, 길이)",
            "지정된 위치에서 지정된 길이만큼 문자열 추출",
            "SUBSTR('HELLO', 2, 3)",
            "ELL",
          ],
          ["LENGTH(문자열)", "문자열의 길이를 반환", "LENGTH('HELLO')", "5"],
          [
            "TRIM(문자열)",
            "문자열 앞뒤의 공백 제거",
            "TRIM(' HELLO ')",
            "HELLO",
          ],
          [
            "CONCAT(문자열1, 문자열2)",
            "두 문자열을 연결",
            "CONCAT('Hello', 'World')",
            "HelloWorld",
          ],
          [
            "REPLACE(문자열, 찾을 문자열, 대체 문자열)",
            "문자열에서 특정 부분을 다른 문자열로 대체",
            "REPLACE('HELLO', 'LL', 'XX')",
            "HEXXO",
          ],
        ],
        caption: "주요 문자 함수",
      },
      {
        type: "subtitle",
        text: "1.2 숫자 함수",
      },
      {
        type: "table",
        headers: ["함수", "설명", "예시", "결과"],
        rows: [
          ["ABS(숫자)", "절대값 반환", "ABS(-15)", "15"],
          [
            "ROUND(숫자, 자릿수)",
            "지정한 자릿수로 반올림",
            "ROUND(123.456, 1)",
            "123.5",
          ],
          [
            "TRUNC(숫자, 자릿수)",
            "지정한 자릿수로 절사",
            "TRUNC(123.456, 1)",
            "123.4",
          ],
          [
            "CEIL(숫자)",
            "숫자보다 크거나 같은 최소 정수",
            "CEIL(123.456)",
            "124",
          ],
          [
            "FLOOR(숫자)",
            "숫자보다 작거나 같은 최대 정수",
            "FLOOR(123.456)",
            "123",
          ],
          [
            "MOD(숫자1, 숫자2)",
            "숫자1을 숫자2로 나눈 나머지",
            "MOD(10, 3)",
            "1",
          ],
          ["POWER(숫자1, 숫자2)", "숫자1의 숫자2승", "POWER(2, 3)", "8"],
        ],
        caption: "주요 숫자 함수",
      },
      {
        type: "subtitle",
        text: "1.3 날짜 함수",
      },
      {
        type: "table",
        headers: ["함수", "설명", "예시", "결과 (예시)"],
        rows: [
          [
            "SYSDATE 또는 CURRENT_DATE",
            "현재 날짜 반환",
            "SYSDATE",
            "2023-05-15",
          ],
          [
            "ADD_MONTHS(날짜, 개월 수)",
            "날짜에 개월 수를 더함",
            "ADD_MONTHS('2023-05-15', 3)",
            "2023-08-15",
          ],
          [
            "MONTHS_BETWEEN(날짜1, 날짜2)",
            "두 날짜 사이의 개월 수 계산",
            "MONTHS_BETWEEN('2023-05-15', '2023-02-15')",
            "3",
          ],
          [
            "LAST_DAY(날짜)",
            "해당 월의 마지막 날짜",
            "LAST_DAY('2023-02-15')",
            "2023-02-28",
          ],
          [
            "EXTRACT(요소 FROM 날짜)",
            "날짜에서 특정 요소(년, 월, 일 등) 추출",
            "EXTRACT(YEAR FROM '2023-05-15')",
            "2023",
          ],
          [
            "TO_DATE(문자열, 형식)",
            "문자열을 날짜로 변환",
            "TO_DATE('2023-05-15', 'YYYY-MM-DD')",
            "2023-05-15 (날짜형)",
          ],
          [
            "TO_CHAR(날짜, 형식)",
            "날짜를 지정한 형식의 문자열로 변환",
            "TO_CHAR(SYSDATE, 'YYYY-MM-DD')",
            "2023-05-15 (문자형)",
          ],
        ],
        caption: "주요 날짜 함수",
      },
      {
        type: "subtitle",
        text: "1.4 변환 함수",
      },
      {
        type: "table",
        headers: ["함수", "설명", "예시", "결과"],
        rows: [
          [
            "TO_CHAR(값, 형식)",
            "숫자 또는 날짜를 문자열로 변환",
            "TO_CHAR(1234.56, '9,999.99')",
            "1,234.56",
          ],
          [
            "TO_NUMBER(문자열)",
            "문자열을 숫자로 변환",
            "TO_NUMBER('1234.56')",
            "1234.56",
          ],
          [
            "TO_DATE(문자열, 형식)",
            "문자열을 날짜로 변환",
            "TO_DATE('2023-05-15', 'YYYY-MM-DD')",
            "2023-05-15 (날짜형)",
          ],
          [
            "CAST(값 AS 데이터타입)",
            "값을 지정한 데이터 타입으로 변환",
            "CAST('123' AS INTEGER)",
            "123 (정수형)",
          ],
        ],
        caption: "주요 변환 함수",
      },
      {
        type: "subtitle",
        text: "1.5 NULL 관련 함수",
      },
      {
        type: "table",
        headers: ["함수", "설명", "예시", "결과"],
        rows: [
          [
            "NVL(값1, 값2) 또는 IFNULL/COALESCE",
            "값1이 NULL이면 값2 반환, 아니면 값1 반환",
            "NVL(NULL, '대체값')",
            "대체값",
          ],
          [
            "NULLIF(값1, 값2)",
            "값1과 값2가 같으면 NULL 반환, 다르면 값1 반환",
            "NULLIF('A', 'A')",
            "NULL",
          ],
          [
            "COALESCE(값1, 값2, ...)",
            "NULL이 아닌 첫 번째 값 반환",
            "COALESCE(NULL, NULL, '값', NULL)",
            "값",
          ],
        ],
        caption: "주요 NULL 관련 함수",
      },
      {
        type: "subtitle",
        text: "1.6 조건 함수",
      },
      {
        type: "table",
        headers: ["함수", "설명", "예시", "결과"],
        rows: [
          [
            "CASE WHEN 조건1 THEN 결과1 WHEN 조건2 THEN 결과2 ELSE 기본결과 END",
            "여러 조건에 따라 다른 결과 반환",
            "CASE WHEN 점수 >= 90 THEN 'A' WHEN 점수 >= 80 THEN 'B' ELSE 'C' END",
            "조건에 따라 'A', 'B', 또는 'C'",
          ],
          [
            "DECODE(컬럼, 값1, 결과1, 값2, 결과2, ..., 기본결과)",
            "컬럼 값에 따라 다른 결과 반환(Oracle 전용)",
            "DECODE(성별, 'M', '남성', 'F', '여성', '기타')",
            "성별 값에 따라 '남성', '여성', 또는 '기타'",
          ],
        ],
        caption: "주요 조건 함수",
      },
      {
        type: "subtitle",
        text: "2. 집계 함수 (Aggregate Functions)",
      },
      {
        type: "paragraph",
        text: "집계 함수는 여러 행의 값을 그룹화하여 하나의 결과를 반환합니다. 주로 GROUP BY 절과 함께 사용됩니다.",
      },
      {
        type: "table",
        headers: ["함수", "설명", "예시"],
        rows: [
          ["COUNT(컬럼 또는 *)", "행의 수를 계산", "COUNT(*) FROM 학생"],
          ["SUM(컬럼)", "합계 계산", "SUM(성적) FROM 수강"],
          ["AVG(컬럼)", "평균 계산", "AVG(성적) FROM 수강"],
          ["MAX(컬럼)", "최대값 반환", "MAX(성적) FROM 수강"],
          ["MIN(컬럼)", "최소값 반환", "MIN(성적) FROM 수강"],
          ["STDDEV(컬럼)", "표준편차 계산", "STDDEV(성적) FROM 수강"],
          ["VARIANCE(컬럼)", "분산 계산", "VARIANCE(성적) FROM 수강"],
        ],
        caption: "주요 집계 함수",
      },
      {
        type: "code",
        text: `-- 학과별 학생 수와 평균 학년 조회
SELECT 학과코드, COUNT(*) AS 학생수, AVG(학년) AS 평균학년
FROM 학생
GROUP BY 학과코드;

-- 학과별, 학년별 학생 수 조회
SELECT 학과코드, 학년, COUNT(*) AS 학생수
FROM 학생
GROUP BY 학과코드, 학년
ORDER BY 학과코드, 학년;

-- 각 과목별 최고 성적과 최저 성적 조회
SELECT 과목코드, MAX(성적) AS 최고성적, MIN(성적) AS 최저성적
FROM 수강
GROUP BY 과목코드;`,
      },
      {
        type: "subtitle",
        text: "3. 분석 함수(Analytic Functions)와 윈도우 함수(Window Functions)",
      },
      {
        type: "paragraph",
        text: "분석 함수와 윈도우 함수는 집계 함수와 유사하지만, 결과를 그룹당 하나가 아닌 각 행에 대해 반환합니다. 이를 통해 행 단위 처리와 그룹 단위 집계를 동시에 수행할 수 있습니다.",
      },
      {
        type: "table",
        headers: ["함수", "설명", "예시"],
        rows: [
          [
            "ROW_NUMBER()",
            "결과 집합의 각 행에 고유한 순번 부여",
            "ROW_NUMBER() OVER(ORDER BY 성적 DESC)",
          ],
          [
            "RANK()",
            "동일한 값에 대해 동일한 순위 부여(건너뛰기 포함)",
            "RANK() OVER(ORDER BY 성적 DESC)",
          ],
          [
            "DENSE_RANK()",
            "동일한 값에 대해 동일한 순위 부여(건너뛰기 없음)",
            "DENSE_RANK() OVER(ORDER BY 성적 DESC)",
          ],
          [
            "NTILE(n)",
            "결과를 n개의 그룹으로 균등하게 분할",
            "NTILE(4) OVER(ORDER BY 성적 DESC)",
          ],
          [
            "LAG(컬럼, n)",
            "현재 행에서 n행 이전의 값 반환",
            "LAG(성적, 1) OVER(ORDER BY 학번)",
          ],
          [
            "LEAD(컬럼, n)",
            "현재 행에서 n행 이후의 값 반환",
            "LEAD(성적, 1) OVER(ORDER BY 학번)",
          ],
          [
            "SUM() OVER()",
            "누적 합계 또는 윈도우 합계 계산",
            "SUM(성적) OVER(PARTITION BY 과목코드 ORDER BY 학번)",
          ],
        ],
        caption: "주요 분석 함수와 윈도우 함수",
      },
      {
        type: "code",
        text: `-- 성적 순위 부여
SELECT 학번, 과목코드, 성적,
       RANK() OVER(ORDER BY 성적 DESC) AS 전체순위,
       RANK() OVER(PARTITION BY 과목코드 ORDER BY 성적 DESC) AS 과목내순위
FROM 수강;

-- 학번별 성적 누적 합계
SELECT 학번, 과목코드, 성적,
       SUM(성적) OVER(PARTITION BY 학번 ORDER BY 과목코드) AS 누적성적
FROM 수강;

-- 이전 학기와 다음 학기 성적 비교
SELECT 학번, 년도, 학기, AVG(성적) AS 평균성적,
       LAG(AVG(성적)) OVER(PARTITION BY 학번 ORDER BY 년도, 학기) AS 이전학기성적,
       LEAD(AVG(성적)) OVER(PARTITION BY 학번 ORDER BY 년도, 학기) AS 다음학기성적
FROM 수강
GROUP BY 학번, 년도, 학기;`,
      },
      {
        type: "subtitle",
        text: "함수 사용 시 주의사항",
      },
      {
        type: "list",
        items: [
          "데이터베이스 시스템마다 지원하는 함수가 다를 수 있음",
          "동일한 기능의 함수라도 이름이나 사용법이 다를 수 있음 (예: Oracle의 NVL vs. MySQL의 IFNULL)",
          "함수 중첩 사용 시 안쪽에서 바깥쪽 순서로 실행됨",
          "NULL 값을 포함한 연산은 결과가 NULL이 되므로, NULL 처리 함수를 적절히 사용해야 함",
          "대용량 데이터에 복잡한 함수를 사용하면 성능 저하가 발생할 수 있음",
        ],
      },
      {
        type: "subtitle",
        text: "실제 활용 예시",
      },
      {
        type: "code",
        text: `-- 학생 이름을 '성, 이름' 형식으로 변환
SELECT 학번, CONCAT(SUBSTR(이름, 1, 1), ', ', SUBSTR(이름, 2)) AS 변환이름
FROM 학생;

-- 오늘 날짜 기준으로 학생 나이 계산
SELECT 학번, 이름, 생년월일,
       EXTRACT(YEAR FROM CURRENT_DATE) - EXTRACT(YEAR FROM 생년월일) AS 나이
FROM 학생;

-- 성적을 등급으로 변환
SELECT 학번, 과목코드, 성적,
       CASE
         WHEN 성적 >= 90 THEN 'A'
         WHEN 성적 >= 80 THEN 'B'
         WHEN 성적 >= 70 THEN 'C'
         WHEN 성적 >= 60 THEN 'D'
         ELSE 'F'
       END AS 성적등급
FROM 수강;

-- 학과별 평균 성적과 전체 평균의 차이 계산
SELECT 학과.학과코드, 학과.학과명,
       AVG(수강.성적) AS 학과평균,
       (SELECT AVG(성적) FROM 수강) AS 전체평균,
       AVG(수강.성적) - (SELECT AVG(성적) FROM 수강) AS 차이
FROM 학과
JOIN 학생 ON 학과.학과코드 = 학생.학과코드
JOIN 수강 ON 학생.학번 = 수강.학번
GROUP BY 학과.학과코드, 학과.학과명;`,
      },
      {
        type: "paragraph",
        text: "SQL 함수를 올바르게 사용하면 복잡한 데이터 처리와 분석 작업을 효율적으로 수행할 수 있습니다. 특히 단일행 함수와 집계 함수를 조합하여 사용하면 다양한 비즈니스 요구사항을 충족시킬 수 있습니다. 함수마다 특성과 사용법이 다르므로, 문제 해결에 적합한 함수를 선택하는 것이 중요합니다.",
      },
    ],
  },
  "SELECT 문": {
    title: "SELECT 문",
    content: [
      {
        type: "paragraph",
        text: "SELECT 문은 관계형 데이터베이스에서 데이터를 조회하는 가장 기본적이고 핵심적인 SQL 명령어입니다. 데이터를 검색, 필터링, 정렬, 그룹화하는 등 다양한 작업을 수행할 수 있습니다.",
      },
      {
        type: "examples",
        text: "예: 학생 테이블에서 모든 학생의 정보를 조회하거나, 특정 학과의 학생만 조회하거나, 학생들의 평균 성적을 계산하는 등의 작업을 SELECT 문으로 수행할 수 있습니다.",
      },
      {
        type: "subtitle",
        text: "기본 SELECT 문 구조",
      },
      {
        type: "code",
        text: `SELECT [DISTINCT] 컬럼1, 컬럼2, ... [AS 별칭]
FROM 테이블명 [별칭]
[WHERE 조건식]
[GROUP BY 그룹화할_컬럼]
[HAVING 그룹_조건식]
[ORDER BY 정렬할_컬럼 [ASC|DESC]];`,
      },
      {
        type: "subtitle",
        text: "SELECT 문의 주요 절(clause)",
      },
      {
        type: "table",
        headers: ["절", "설명", "사용 예시"],
        rows: [
          [
            "SELECT",
            "조회할 컬럼을 지정",
            "SELECT 학번, 이름, 학과코드 또는 SELECT *",
          ],
          ["FROM", "데이터를 가져올 테이블 지정", "FROM 학생 또는 FROM 학생 S"],
          [
            "WHERE",
            "조회할 행을 필터링하는 조건 지정",
            "WHERE 학과코드 = 'CS'",
          ],
          ["GROUP BY", "결과를 그룹화할 컬럼 지정", "GROUP BY 학과코드"],
          [
            "HAVING",
            "그룹화된 결과를 필터링하는 조건 지정",
            "HAVING COUNT(*) > 5",
          ],
          ["ORDER BY", "결과를 정렬할 기준 컬럼 지정", "ORDER BY 이름 ASC"],
        ],
        caption: "SELECT 문의 주요 절",
      },
      {
        type: "subtitle",
        text: "SELECT 문의 논리적 실행 순서",
      },
      {
        type: "list",
        items: [
          "1. FROM: 조회할 테이블 확인",
          "2. WHERE: 조건에 맞는 행 필터링",
          "3. GROUP BY: 지정된 컬럼으로 그룹화",
          "4. HAVING: 그룹화된 결과 필터링",
          "5. SELECT: 지정된 컬럼 선택",
          "6. ORDER BY: 결과 정렬",
        ],
      },
      {
        type: "paragraph",
        text: "이 실행 순서를 이해하는 것은 SQL 쿼리를 작성하고 디버깅하는 데 매우 중요합니다. 예를 들어, SELECT 절에서 정의한 별칭은 WHERE 절에서 사용할 수 없지만 ORDER BY 절에서는 사용할 수 있습니다. 이는 SELECT 절이 WHERE 절 이후, ORDER BY 절 이전에 실행되기 때문입니다.",
      },
      {
        type: "subtitle",
        text: "샘플 테이블 데이터",
      },
      {
        type: "paragraph",
        text: "다음 샘플 테이블을 사용하여 SELECT 문의 다양한 사용 예를 살펴봅시다.",
      },
      {
        type: "table",
        headers: ["학번", "이름", "학과코드", "학년", "생년월일"],
        rows: [
          ["2023001", "김철수", "CS", "1", "2004-05-10"],
          ["2023002", "이영희", "MA", "1", "2004-08-15"],
          ["2022001", "박지민", "CS", "2", "2003-01-22"],
          ["2022002", "최유진", "PH", "2", "2003-11-07"],
          ["2021001", "정민준", "CS", "3", "2002-03-30"],
        ],
        caption: "학생(STUDENT) 테이블",
      },
      {
        type: "table",
        headers: ["학과코드", "학과명", "위치", "전화번호"],
        rows: [
          ["CS", "컴퓨터공학과", "공학관 1층", "02-1234-5678"],
          ["MA", "수학과", "이학관 2층", "02-1234-5679"],
          ["PH", "물리학과", "이학관 3층", "02-1234-5680"],
        ],
        caption: "학과(DEPARTMENT) 테이블",
      },
      {
        type: "table",
        headers: ["수강번호", "학번", "과목코드", "년도", "학기", "성적"],
        rows: [
          ["1", "2023001", "CS101", "2023", "1", "95"],
          ["2", "2023001", "MA101", "2023", "1", "88"],
          ["3", "2023002", "MA101", "2023", "1", "92"],
          ["4", "2022001", "CS102", "2023", "1", "90"],
          ["5", "2022002", "PH101", "2023", "1", "85"],
          ["6", "2021001", "CS201", "2023", "1", "93"],
        ],
        caption: "수강(ENROLLMENT) 테이블",
      },
      {
        type: "subtitle",
        text: "1. 기본 SELECT 문",
      },
      {
        type: "code",
        text: `-- 모든 컬럼 조회
SELECT * FROM 학생;

-- 특정 컬럼만 조회
SELECT 학번, 이름, 학과코드 FROM 학생;

-- 컬럼에 별칭 부여
SELECT 학번 AS 학생번호, 이름 AS 학생이름, 학과코드 FROM 학생;
SELECT 학번 학생번호, 이름 학생이름, 학과코드 FROM 학생; -- AS 생략 가능`,
      },
      {
        type: "subtitle",
        text: "2. 조건절 (WHERE)",
      },
      {
        type: "code",
        text: `-- 특정 학과 학생만 조회
SELECT * FROM 학생 WHERE 학과코드 = 'CS';

-- 여러 조건 사용 (AND, OR)
SELECT * FROM 학생 WHERE 학과코드 = 'CS' AND 학년 = 1;
SELECT * FROM 학생 WHERE 학과코드 = 'CS' OR 학과코드 = 'MA';

-- 비교 연산자 사용
SELECT * FROM 학생 WHERE 학년 > 1;
SELECT * FROM 학생 WHERE 생년월일 < '2004-01-01';

-- 특수 연산자 사용
SELECT * FROM 학생 WHERE 학과코드 IN ('CS', 'MA'); -- IN 연산자
SELECT * FROM 학생 WHERE 학년 BETWEEN 1 AND 2; -- BETWEEN 연산자
SELECT * FROM 학생 WHERE 이름 LIKE '김%'; -- LIKE 연산자 (김으로 시작하는 이름)
SELECT * FROM 학생 WHERE 학과코드 IS NOT NULL; -- NULL 검사`,
      },
      {
        type: "subtitle",
        text: "3. 정렬 (ORDER BY)",
      },
      {
        type: "code",
        text: `-- 이름 순으로 오름차순 정렬
SELECT * FROM 학생 ORDER BY 이름 ASC;

-- 학년 내림차순, 이름 오름차순 정렬
SELECT * FROM 학생 ORDER BY 학년 DESC, 이름 ASC;

-- 별칭으로 정렬
SELECT 학번, 이름 AS 학생이름, 학과코드 FROM 학생 ORDER BY 학생이름;

-- 컬럼 위치로 정렬 (권장하지 않음)
SELECT 학번, 이름, 학과코드 FROM 학생 ORDER BY 2; -- 이름으로 정렬`,
      },
      {
        type: "subtitle",
        text: "4. 중복 제거 (DISTINCT)",
      },
      {
        type: "code",
        text: `-- 중복 없이 학과코드만 조회
SELECT DISTINCT 학과코드 FROM 학생;

-- 여러 컬럼의 조합에서 중복 제거
SELECT DISTINCT 학과코드, 학년 FROM 학생;`,
      },
      {
        type: "subtitle",
        text: "5. 집계 함수와 그룹화 (GROUP BY, HAVING)",
      },
      {
        type: "paragraph",
        text: "그룹 함수는 여러 행의 데이터를 하나의 결과로 집계합니다. GROUP BY 절을 사용하면 특정 컬럼 값이 같은 행들을 그룹으로 묶을 수 있습니다.",
      },
      {
        type: "code",
        text: `-- 학과별 학생 수 조회
SELECT 학과코드, COUNT(*) AS 학생수 FROM 학생 GROUP BY 학과코드;

-- 학과별, 학년별 학생 수 조회
SELECT 학과코드, 학년, COUNT(*) AS 학생수 
FROM 학생 
GROUP BY 학과코드, 학년;

-- 학과별 평균 학년 조회
SELECT 학과코드, AVG(학년) AS 평균학년 FROM 학생 GROUP BY 학과코드;

-- HAVING 절로 그룹 필터링
SELECT 학과코드, COUNT(*) AS 학생수 
FROM 학생 
GROUP BY 학과코드 
HAVING COUNT(*) > 1;

-- WHERE와 HAVING 함께 사용
SELECT 학과코드, AVG(학년) AS 평균학년 
FROM 학생 
WHERE 생년월일 > '2003-01-01'
GROUP BY 학과코드 
HAVING AVG(학년) < 2;`,
      },
      {
        type: "subtitle",
        text: "6. 조인 (JOIN)",
      },
      {
        type: "paragraph",
        text: "조인은 둘 이상의 테이블에서 관련된 데이터를 함께 조회하는 방법입니다.",
      },
      {
        type: "code",
        text: `-- 내부 조인 (INNER JOIN)
SELECT S.학번, S.이름, S.학과코드, D.학과명
FROM 학생 S
JOIN 학과 D ON S.학과코드 = D.학과코드;

-- 동등 조인 (= 내부 조인)
SELECT S.학번, S.이름, S.학과코드, D.학과명
FROM 학생 S, 학과 D
WHERE S.학과코드 = D.학과코드;

-- 왼쪽 외부 조인 (LEFT OUTER JOIN)
SELECT S.학번, S.이름, S.학과코드, D.학과명
FROM 학생 S
LEFT JOIN 학과 D ON S.학과코드 = D.학과코드;

-- 여러 테이블 조인
SELECT S.학번, S.이름, D.학과명, E.과목코드, E.성적
FROM 학생 S
JOIN 학과 D ON S.학과코드 = D.학과코드
JOIN 수강 E ON S.학번 = E.학번;`,
      },
      {
        type: "subtitle",
        text: "7. 서브쿼리 (Subquery)",
      },
      {
        type: "paragraph",
        text: "서브쿼리는 하나의 SQL 문 안에 포함된 또 다른 SQL 문입니다. 서브쿼리는 괄호 안에 작성하며, 메인 쿼리의 다양한 위치에서 사용할 수 있습니다.",
      },
      {
        type: "code",
        text: `-- WHERE 절에서 서브쿼리 사용
SELECT 학번, 이름, 학과코드
FROM 학생
WHERE 학과코드 IN (SELECT 학과코드 FROM 학과 WHERE 위치 LIKE '%공학관%');

-- SELECT 절에서 서브쿼리 사용
SELECT 학번, 이름, 
       (SELECT 학과명 FROM 학과 WHERE 학과.학과코드 = 학생.학과코드) AS 학과명
FROM 학생;

-- FROM 절에서 서브쿼리 사용 (인라인 뷰)
SELECT A.학과코드, A.학과명, B.학생수
FROM 학과 A,
     (SELECT 학과코드, COUNT(*) AS 학생수 FROM 학생 GROUP BY 학과코드) B
WHERE A.학과코드 = B.학과코드;`,
      },
      {
        type: "subtitle",
        text: "8. 집합 연산자 (Set Operators)",
      },
      {
        type: "paragraph",
        text: "집합 연산자는 두 개 이상의 SELECT 문 결과를 하나로 결합합니다.",
      },
      {
        type: "code",
        text: `-- UNION: 두 결과를 합치고 중복 제거
SELECT 학번, 이름 FROM 학생 WHERE 학과코드 = 'CS'
UNION
SELECT 학번, 이름 FROM 학생 WHERE 학년 > 1;

-- UNION ALL: 두 결과를 합치고 중복 유지
SELECT 학번, 이름 FROM 학생 WHERE 학과코드 = 'CS'
UNION ALL
SELECT 학번, 이름 FROM 학생 WHERE 학년 > 1;

-- INTERSECT: 두 결과의 교집합
SELECT 학번, 이름 FROM 학생 WHERE 학과코드 = 'CS'
INTERSECT
SELECT 학번, 이름 FROM 학생 WHERE 학년 > 1;

-- MINUS/EXCEPT: 첫 번째 결과에서 두 번째 결과를 제외
SELECT 학번, 이름 FROM 학생 WHERE 학과코드 = 'CS'
MINUS
SELECT 학번, 이름 FROM 학생 WHERE 학년 > 1;`,
      },
      {
        type: "subtitle",
        text: "9. 복합 쿼리 예제",
      },
      {
        type: "paragraph",
        text: "실제 업무에서는 다양한 SQL 기능을 조합하여 복잡한 쿼리를 작성하는 경우가 많습니다.",
      },
      {
        type: "code",
        text: `-- 각 학과별 평균 성적이 90점 이상인 학과 조회
SELECT D.학과코드, D.학과명, AVG(E.성적) AS 평균성적
FROM 학과 D
JOIN 학생 S ON D.학과코드 = S.학과코드
JOIN 수강 E ON S.학번 = E.학번
GROUP BY D.학과코드, D.학과명
HAVING AVG(E.성적) >= 90
ORDER BY 평균성적 DESC;

-- 각 학생의 수강 과목 수와 평균 성적 조회
SELECT S.학번, S.이름, S.학과코드, D.학과명,
       COUNT(E.수강번호) AS 수강과목수,
       AVG(E.성적) AS 평균성적
FROM 학생 S
JOIN 학과 D ON S.학과코드 = D.학과코드
LEFT JOIN 수강 E ON S.학번 = E.학번
GROUP BY S.학번, S.이름, S.학과코드, D.학과명
ORDER BY 평균성적 DESC NULLS LAST;

-- 학과별 최고 성적 학생 조회 (서브쿼리와 조인 활용)
SELECT D.학과코드, D.학과명, S.학번, S.이름, AVG(E.성적) AS 평균성적
FROM 학과 D
JOIN 학생 S ON D.학과코드 = S.학과코드
JOIN 수강 E ON S.학번 = E.학번
GROUP BY D.학과코드, D.학과명, S.학번, S.이름
HAVING (D.학과코드, AVG(E.성적)) IN (
    SELECT 학과코드, MAX(평균성적)
    FROM (
        SELECT S2.학과코드, S2.학번, AVG(E2.성적) AS 평균성적
        FROM 학생 S2
        JOIN 수강 E2 ON S2.학번 = E2.학번
        GROUP BY S2.학과코드, S2.학번
    )
    GROUP BY 학과코드
)
ORDER BY D.학과코드;`,
      },
      {
        type: "subtitle",
        text: "10. SELECT 문 작성 시 주의사항",
      },
      {
        type: "list",
        items: [
          "항상 필요한 컬럼만 선택하기 (SELECT * 지양)",
          "대용량 테이블 조회 시 적절한 WHERE 조건 사용하기",
          "인덱스를 활용할 수 있는 조건 우선 사용하기",
          "복잡한 조인과 서브쿼리는 성능에 영향을 줄 수 있음",
          "GROUP BY 절에는 SELECT 절에 있는 집계함수가 아닌 모든 컬럼이 포함되어야 함",
          "ORDER BY는 쿼리의 마지막에 실행되므로 SELECT 절의 별칭 사용 가능",
        ],
      },
      {
        type: "paragraph",
        text: "SELECT 문은 SQL의 가장 기본적인 명령어지만 동시에 가장 강력하고 다양한 기능을 제공합니다. 복잡한 데이터 조회, 분석, 집계 등 다양한 요구사항을 충족할 수 있는 유연성을 가지고 있습니다. 효과적인 SELECT 문 작성을 위해서는 각 절의 기능과 실행 순서를 이해하고, 데이터베이스의 성능을 고려하여 적절한 쿼리를 설계하는 것이 중요합니다.",
      },
    ],
  },
  // 다른 주제들에 대한 내용은 계속 추가될 예정입니다.
  // 데이터 모델과 SQL, SQL 기본, SQL 활용, 관리 구문 등
};

export default studyContent;
